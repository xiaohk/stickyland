{"version":3,"file":"1647.6591860.js","mappings":"4LAOO,MAAMA,EAAkB,I,SAAIC,OAAM,uC,qCCCzC,MAQMC,EAAa,iBAYbC,GAAc,EAIb,MAAMC,UAAgB,EAAAC,OAIzBC,YAAYC,GACRC,QACAC,KAAKC,SAAW,KAChB,MAAMC,EAAUF,KAAKE,OAAS,IAAI,EAAAC,YAC5BC,EAAQ,IAAI,EAAAC,UAAU,CAAEC,KAAMR,EAAQS,SAC5CP,KAAKQ,OAASV,EAAQU,OACtBR,KAAKS,SAlCS,cAmCdT,KAAKU,OACLV,KAAKW,QAAUb,EAAQc,OACvBZ,KAAKa,UAAYf,EAAQgB,SACzBd,KAAKe,YAAcjB,EAAQkB,WAC3B,MAAMC,EAAWjB,KAAKe,YAAYG,kBAAkBpB,EAAQS,OAAQ,OAC/DU,IAGLjB,KAAKC,SAAWD,KAAKe,YAAYI,eAAeF,GAChDjB,KAAKC,SACAmB,YAAYhB,GACZiB,MAAK,IAAMrB,KAAKsB,iBAChBC,OAAMC,GAASC,QAAQD,MAAM,2BAA4BA,KAC9DxB,KAAKC,SAASQ,SA5CA,sBA6CdP,EAAOwB,UAAU1B,KAAKC,WAK1B0B,UACQ3B,KAAKC,WACLD,KAAKC,SAAS0B,UACd3B,KAAKC,SAAW,MAEpBF,MAAM4B,UAYVC,YAAYC,GACR,GAAI7B,KAAK8B,UAAY9B,KAAK+B,WACtB,OAEJ,MAAM,KAAEC,GAAShC,KACXiC,EAASJ,EAAMI,OACrB,OAAQJ,EAAMK,MACV,IAAK,UACD,GAAIF,EAAKG,SAASF,GACd,OAEJjC,KAAK2B,UACL,MACJ,IAAK,YACD,GAAIK,EAAKG,SAASF,GAEd,YADAjC,KAAKoC,WAGTpC,KAAK2B,UACL,MACJ,IAAK,SACD3B,KAAKqC,WAAWR,IAS5BS,kBAAkBC,GACdvC,KAAKgC,KAAKQ,SAAW,EACrBxC,KAAKgC,KAAKS,QAKdC,cAAcH,GACVI,SAASC,KAAKC,UAAUC,IAAIrD,GAC5BkD,SAASI,iBAAiB,UAAW/C,KAAMN,GAC3CiD,SAASI,iBAAiB,YAAa/C,KAAMN,GAC7CM,KAAKQ,OAAOwB,KAAKe,iBAAiB,SAAU/C,KAAMN,GAClDM,KAAKgD,SAKTC,eAAeV,GACXI,SAASC,KAAKC,UAAUK,OAAOzD,GAC/BkD,SAASQ,oBAAoB,UAAWnD,KAAMN,GAC9CiD,SAASQ,oBAAoB,YAAanD,KAAMN,GAChDM,KAAKQ,OAAOwB,KAAKmB,oBAAoB,SAAUnD,KAAMN,GAKzD0D,gBAAgBb,GACRvC,KAAK8B,UACL9B,KAAKqD,OAETrD,KAAKsB,eACLvB,MAAMqD,gBAAgBb,GAK1BF,WAAWR,GAIH7B,KAAKgC,KAAKG,SAASN,EAAMI,SAG7BjC,KAAKgD,SAKTM,oBACI,MAAM1C,EAASZ,KAAKW,QACd4C,EAAS3C,EAAO4C,oBAChBC,EAAM7C,EAAO8C,YAAYH,GACzBI,EAAO/C,EAAOgD,QAAQL,EAAOI,MACnC,IAAKA,EACD,OAEJ,MAAME,EAASF,EAAKG,UAAU,EAAGL,GAAKM,MAAM,OACtCC,EAAOH,EAAOA,EAAOI,OAAS,GAC9BC,EAAQF,EAAOP,EAAMO,EAAKC,OAASR,EACzC,OAAO7C,EAAOuD,cAAcD,GAKhC5C,eAEI,MAAMR,EAAWd,KAAKa,UAAYb,KAAKa,UAAYb,KAAKsD,oBACxD,IAAKxC,EACD,OAEJ,MAAMF,EAASZ,KAAKW,QACdH,EAASI,EAAOwD,yBAAyBtD,GACzCuD,EAAQC,OAAOC,iBAAiBvE,KAAKgC,MACrCwC,EAAcC,SAASJ,EAAMG,YAAa,KAAO,EAEvD,EAAAE,SAAA,YAAqB,CACjBlE,OAAAA,EACAmE,KAAM/D,EAAO+D,KACbC,UAnKO,IAoKPC,UAxKO,GAyKP7C,KAAMhC,KAAKgC,KACX8C,OAAQ,CAAEC,YAAa,EAAIP,GAC3BQ,UAAW,QACXX,MAAOA","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip/lib/widget.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The tooltip manager token.\n */\nexport const ITooltipManager = new Token('@jupyterlab/tooltip:ITooltipManager');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { HoverBox } from '@jupyterlab/apputils';\nimport { MimeModel } from '@jupyterlab/rendermime';\nimport { PanelLayout, Widget } from '@lumino/widgets';\n/**\n * The class name added to each tooltip.\n */\nconst TOOLTIP_CLASS = 'jp-Tooltip';\n/**\n * The class name added to the tooltip content.\n */\nconst CONTENT_CLASS = 'jp-Tooltip-content';\n/**\n * The class added to the body when a tooltip exists on the page.\n */\nconst BODY_CLASS = 'jp-mod-tooltip';\n/**\n * The minimum height of a tooltip widget.\n */\nconst MIN_HEIGHT = 20;\n/**\n * The maximum height of a tooltip widget.\n */\nconst MAX_HEIGHT = 250;\n/**\n * A flag to indicate that event handlers are caught in the capture phase.\n */\nconst USE_CAPTURE = true;\n/**\n * A tooltip widget.\n */\nexport class Tooltip extends Widget {\n    /**\n     * Instantiate a tooltip.\n     */\n    constructor(options) {\n        super();\n        this._content = null;\n        const layout = (this.layout = new PanelLayout());\n        const model = new MimeModel({ data: options.bundle });\n        this.anchor = options.anchor;\n        this.addClass(TOOLTIP_CLASS);\n        this.hide();\n        this._editor = options.editor;\n        this._position = options.position;\n        this._rendermime = options.rendermime;\n        const mimeType = this._rendermime.preferredMimeType(options.bundle, 'any');\n        if (!mimeType) {\n            return;\n        }\n        this._content = this._rendermime.createRenderer(mimeType);\n        this._content\n            .renderModel(model)\n            .then(() => this._setGeometry())\n            .catch(error => console.error('tooltip rendering failed', error));\n        this._content.addClass(CONTENT_CLASS);\n        layout.addWidget(this._content);\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this._content) {\n            this._content.dispose();\n            this._content = null;\n        }\n        super.dispose();\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the dock panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (this.isHidden || this.isDisposed) {\n            return;\n        }\n        const { node } = this;\n        const target = event.target;\n        switch (event.type) {\n            case 'keydown':\n                if (node.contains(target)) {\n                    return;\n                }\n                this.dispose();\n                break;\n            case 'mousedown':\n                if (node.contains(target)) {\n                    this.activate();\n                    return;\n                }\n                this.dispose();\n                break;\n            case 'scroll':\n                this._evtScroll(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        this.node.tabIndex = 0;\n        this.node.focus();\n    }\n    /**\n     * Handle `'after-attach'` messages.\n     */\n    onAfterAttach(msg) {\n        document.body.classList.add(BODY_CLASS);\n        document.addEventListener('keydown', this, USE_CAPTURE);\n        document.addEventListener('mousedown', this, USE_CAPTURE);\n        this.anchor.node.addEventListener('scroll', this, USE_CAPTURE);\n        this.update();\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        document.body.classList.remove(BODY_CLASS);\n        document.removeEventListener('keydown', this, USE_CAPTURE);\n        document.removeEventListener('mousedown', this, USE_CAPTURE);\n        this.anchor.node.removeEventListener('scroll', this, USE_CAPTURE);\n    }\n    /**\n     * Handle `'update-request'` messages.\n     */\n    onUpdateRequest(msg) {\n        if (this.isHidden) {\n            this.show();\n        }\n        this._setGeometry();\n        super.onUpdateRequest(msg);\n    }\n    /**\n     * Handle scroll events for the widget\n     */\n    _evtScroll(event) {\n        // All scrolls except scrolls in the actual hover box node may cause the\n        // referent editor that anchors the node to move, so the only scroll events\n        // that can safely be ignored are ones that happen inside the hovering node.\n        if (this.node.contains(event.target)) {\n            return;\n        }\n        this.update();\n    }\n    /**\n     * Find the position of the first character of the current token.\n     */\n    _getTokenPosition() {\n        const editor = this._editor;\n        const cursor = editor.getCursorPosition();\n        const end = editor.getOffsetAt(cursor);\n        const line = editor.getLine(cursor.line);\n        if (!line) {\n            return;\n        }\n        const tokens = line.substring(0, end).split(/\\W+/);\n        const last = tokens[tokens.length - 1];\n        const start = last ? end - last.length : end;\n        return editor.getPositionAt(start);\n    }\n    /**\n     * Set the geometry of the tooltip widget.\n     */\n    _setGeometry() {\n        // determine position for hover box placement\n        const position = this._position ? this._position : this._getTokenPosition();\n        if (!position) {\n            return;\n        }\n        const editor = this._editor;\n        const anchor = editor.getCoordinateForPosition(position);\n        const style = window.getComputedStyle(this.node);\n        const paddingLeft = parseInt(style.paddingLeft, 10) || 0;\n        // Calculate the geometry of the tooltip.\n        HoverBox.setGeometry({\n            anchor,\n            host: editor.host,\n            maxHeight: MAX_HEIGHT,\n            minHeight: MIN_HEIGHT,\n            node: this.node,\n            offset: { horizontal: -1 * paddingLeft },\n            privilege: 'below',\n            style: style\n        });\n    }\n}\n//# sourceMappingURL=widget.js.map"],"names":["ITooltipManager","Token","BODY_CLASS","USE_CAPTURE","Tooltip","Widget","constructor","options","super","this","_content","layout","PanelLayout","model","MimeModel","data","bundle","anchor","addClass","hide","_editor","editor","_position","position","_rendermime","rendermime","mimeType","preferredMimeType","createRenderer","renderModel","then","_setGeometry","catch","error","console","addWidget","dispose","handleEvent","event","isHidden","isDisposed","node","target","type","contains","activate","_evtScroll","onActivateRequest","msg","tabIndex","focus","onAfterAttach","document","body","classList","add","addEventListener","update","onBeforeDetach","remove","removeEventListener","onUpdateRequest","show","_getTokenPosition","cursor","getCursorPosition","end","getOffsetAt","line","getLine","tokens","substring","split","last","length","start","getPositionAt","getCoordinateForPosition","style","window","getComputedStyle","paddingLeft","parseInt","HoverBox","host","maxHeight","minHeight","offset","horizontal","privilege"],"sourceRoot":""}