{"version":3,"file":"2088.c17eb4d.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip-extension/lib/index.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module tooltip-extension\n */\nimport { IConsoleTracker } from '@jupyterlab/console';\nimport { Text } from '@jupyterlab/coreutils';\nimport { IEditorTracker } from '@jupyterlab/fileeditor';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { ITooltipManager, Tooltip } from '@jupyterlab/tooltip';\nimport { find, toArray } from '@lumino/algorithm';\nimport { Widget } from '@lumino/widgets';\n/**\n * The command IDs used by the tooltip plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.dismiss = 'tooltip:dismiss';\n    CommandIDs.launchConsole = 'tooltip:launch-console';\n    CommandIDs.launchNotebook = 'tooltip:launch-notebook';\n    CommandIDs.launchFile = 'tooltip:launch-file';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * The main tooltip manager plugin.\n */\nconst manager = {\n    id: '@jupyterlab/tooltip-extension:manager',\n    autoStart: true,\n    provides: ITooltipManager,\n    activate: (app) => {\n        let tooltip = null;\n        // Add tooltip dismiss command.\n        app.commands.addCommand(CommandIDs.dismiss, {\n            execute: () => {\n                if (tooltip) {\n                    tooltip.dispose();\n                    tooltip = null;\n                }\n            }\n        });\n        return {\n            invoke(options) {\n                const detail = 0;\n                const { anchor, editor, kernel, rendermime } = options;\n                if (tooltip) {\n                    tooltip.dispose();\n                    tooltip = null;\n                }\n                return Private.fetch({ detail, editor, kernel })\n                    .then(bundle => {\n                    tooltip = new Tooltip({ anchor, bundle, editor, rendermime });\n                    Widget.attach(tooltip, document.body);\n                })\n                    .catch(() => {\n                    /* Fails silently. */\n                });\n            }\n        };\n    }\n};\n/**\n * The console tooltip plugin.\n */\nconst consoles = {\n    id: '@jupyterlab/tooltip-extension:consoles',\n    autoStart: true,\n    requires: [ITooltipManager, IConsoleTracker],\n    activate: (app, manager, consoles) => {\n        // Add tooltip launch command.\n        app.commands.addCommand(CommandIDs.launchConsole, {\n            execute: () => {\n                var _a, _b;\n                const parent = consoles.currentWidget;\n                if (!parent) {\n                    return;\n                }\n                const anchor = parent.console;\n                const editor = (_a = anchor.promptCell) === null || _a === void 0 ? void 0 : _a.editor;\n                const kernel = (_b = anchor.sessionContext.session) === null || _b === void 0 ? void 0 : _b.kernel;\n                const rendermime = anchor.rendermime;\n                // If all components necessary for rendering exist, create a tooltip.\n                if (!!editor && !!kernel && !!rendermime) {\n                    return manager.invoke({ anchor, editor, kernel, rendermime });\n                }\n            }\n        });\n    }\n};\n/**\n * The notebook tooltip plugin.\n */\nconst notebooks = {\n    id: '@jupyterlab/tooltip-extension:notebooks',\n    autoStart: true,\n    requires: [ITooltipManager, INotebookTracker],\n    activate: (app, manager, notebooks) => {\n        // Add tooltip launch command.\n        app.commands.addCommand(CommandIDs.launchNotebook, {\n            execute: () => {\n                var _a, _b;\n                const parent = notebooks.currentWidget;\n                if (!parent) {\n                    return;\n                }\n                const anchor = parent.content;\n                const editor = (_a = anchor.activeCell) === null || _a === void 0 ? void 0 : _a.editor;\n                const kernel = (_b = parent.sessionContext.session) === null || _b === void 0 ? void 0 : _b.kernel;\n                const rendermime = anchor.rendermime;\n                // If all components necessary for rendering exist, create a tooltip.\n                if (!!editor && !!kernel && !!rendermime) {\n                    return manager.invoke({ anchor, editor, kernel, rendermime });\n                }\n            }\n        });\n    }\n};\n/**\n * The file editor tooltip plugin.\n */\nconst files = {\n    id: '@jupyterlab/tooltip-extension:files',\n    autoStart: true,\n    requires: [ITooltipManager, IEditorTracker, IRenderMimeRegistry],\n    activate: (app, manager, editorTracker, rendermime) => {\n        // Keep a list of active ISessions so that we can\n        // clean them up when they are no longer needed.\n        const activeSessions = {};\n        const sessions = app.serviceManager.sessions;\n        // When the list of running sessions changes,\n        // check to see if there are any kernels with a\n        // matching path for the file editors.\n        const onRunningChanged = (sender, models) => {\n            editorTracker.forEach(file => {\n                const model = find(models, m => file.context.path === m.path);\n                if (model) {\n                    const oldSession = activeSessions[file.id];\n                    // If there is a matching path, but it is the same\n                    // session as we previously had, do nothing.\n                    if (oldSession && oldSession.id === model.id) {\n                        return;\n                    }\n                    // Otherwise, dispose of the old session and reset to\n                    // a new CompletionConnector.\n                    if (oldSession) {\n                        delete activeSessions[file.id];\n                        oldSession.dispose();\n                    }\n                    const session = sessions.connectTo({ model });\n                    activeSessions[file.id] = session;\n                }\n                else {\n                    const session = activeSessions[file.id];\n                    if (session) {\n                        session.dispose();\n                        delete activeSessions[file.id];\n                    }\n                }\n            });\n        };\n        onRunningChanged(sessions, toArray(sessions.running()));\n        sessions.runningChanged.connect(onRunningChanged);\n        // Clean up after a widget when it is disposed\n        editorTracker.widgetAdded.connect((sender, widget) => {\n            widget.disposed.connect(w => {\n                const session = activeSessions[w.id];\n                if (session) {\n                    session.dispose();\n                    delete activeSessions[w.id];\n                }\n            });\n        });\n        // Add tooltip launch command.\n        app.commands.addCommand(CommandIDs.launchFile, {\n            execute: async () => {\n                const parent = editorTracker.currentWidget;\n                const kernel = parent &&\n                    activeSessions[parent.id] &&\n                    activeSessions[parent.id].kernel;\n                if (!kernel) {\n                    return;\n                }\n                const anchor = parent.content;\n                const editor = anchor === null || anchor === void 0 ? void 0 : anchor.editor;\n                // If all components necessary for rendering exist, create a tooltip.\n                if (!!editor && !!kernel && !!rendermime) {\n                    return manager.invoke({ anchor, editor, kernel, rendermime });\n                }\n            }\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    manager,\n    consoles,\n    notebooks,\n    files\n];\nexport default plugins;\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A counter for outstanding requests.\n     */\n    let pending = 0;\n    /**\n     * Fetch a tooltip's content from the API server.\n     */\n    function fetch(options) {\n        const { detail, editor, kernel } = options;\n        const code = editor.model.value.text;\n        const position = editor.getCursorPosition();\n        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), code);\n        // Clear hints if the new text value is empty or kernel is unavailable.\n        if (!code || !kernel) {\n            return Promise.reject(void 0);\n        }\n        const contents = {\n            code,\n            cursor_pos: offset,\n            detail_level: detail || 0\n        };\n        const current = ++pending;\n        return kernel.requestInspect(contents).then(msg => {\n            const value = msg.content;\n            // If a newer request is pending, bail.\n            if (current !== pending) {\n                return Promise.reject(void 0);\n            }\n            // If request fails or returns negative results, bail.\n            if (value.status !== 'ok' || !value.found) {\n                return Promise.reject(void 0);\n            }\n            return Promise.resolve(value.data);\n        });\n    }\n    Private.fetch = fetch;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"],"names":["CommandIDs","dismiss","launchConsole","launchNotebook","launchFile","manager","id","autoStart","provides","ITooltipManager","activate","app","tooltip","commands","addCommand","execute","dispose","invoke","options","anchor","editor","kernel","rendermime","Private","fetch","detail","then","bundle","Tooltip","Widget","document","body","catch","consoles","requires","IConsoleTracker","_a","_b","parent","currentWidget","console","promptCell","sessionContext","session","notebooks","INotebookTracker","content","activeCell","files","IEditorTracker","IRenderMimeRegistry","editorTracker","activeSessions","sessions","serviceManager","onRunningChanged","sender","models","forEach","file","model","find","m","context","path","oldSession","connectTo","toArray","running","runningChanged","connect","widgetAdded","widget","disposed","w","async","pending","code","value","text","position","getCursorPosition","offset","Text","getOffsetAt","Promise","reject","contents","cursor_pos","detail_level","current","requestInspect","msg","status","found","resolve","data"],"sourceRoot":""}