{"version":3,"file":"3151.f63a553.js","mappings":"+VAQO,MAAMA,UAAuB,EAAAC,cAChCC,MAAMC,GACF,OAAOC,QAAQC,OAAO,0FCD9B,MAAMC,EAA0B,2BAI1BC,EAAyB,0BAIxB,MAAMC,EAITC,YAAYC,GACRC,KAAKC,QAAU,KACfD,KAAKE,UAAW,EAChBF,KAAKG,SAAW,EAChBH,KAAKI,aAAc,EACnBJ,KAAKK,UAAYN,EAAQM,UACzBL,KAAKK,UAAUC,SAASC,QAAQP,KAAKQ,qBAAsBR,MAC3DA,KAAKK,UAAUI,kBAAkBF,QAAQP,KAAKU,oBAAqBV,MACnEA,KAAKW,WAAaZ,EAAQa,UAY1BA,gBACA,MAAI,iBAAkBZ,KAAKW,WAChB,IAAItB,EAERW,KAAKW,WAEZC,cAAUA,GACVZ,KAAKW,WAAaC,EAKlBC,aACA,OAAOb,KAAKC,QAEZY,WAAOC,GACP,GAAIA,IAAad,KAAKC,QAClB,OAEJ,IAAIY,EAASb,KAAKC,QAElB,GAAIY,IAAWA,EAAOE,WAAY,CAC9B,MAAMC,EAAQH,EAAOG,MACrBH,EAAOI,KAAKC,UAAUC,OAAOxB,GAC7BkB,EAAOI,KAAKC,UAAUC,OAAOvB,GAC7BoB,EAAMI,WAAWC,QAAQC,WAAWtB,KAAKuB,oBAAqBvB,MAC9DgB,EAAMQ,MAAMH,QAAQC,WAAWtB,KAAKyB,cAAezB,MAOvD,GAJAA,KAAKK,UAAUqB,QACf1B,KAAKK,UAAUQ,OAASC,EAExBD,EAASb,KAAKC,QAAUa,EACpBD,EAAQ,CACR,MAAMG,EAAQH,EAAOG,MACrBhB,KAAKE,UAAW,EAChBc,EAAMI,WAAWC,QAAQd,QAAQP,KAAKuB,oBAAqBvB,MAC3DgB,EAAMQ,MAAMH,QAAQd,QAAQP,KAAKyB,cAAezB,MAEhDA,KAAKuB,uBAMTR,iBACA,OAAOf,KAAKI,YAKhBuB,UACQ3B,KAAKe,aAGTf,KAAKI,aAAc,EACnB,EAAAwB,OAAA,UAAiB5B,OAKrB6B,SACI,EAAAC,YAAA,YAAwB9B,KAAMH,EAAkBkC,IAAIC,eAKxDC,eAAeC,GACHA,EAAIC,OACHtC,EAAkBkC,IAAIC,cAAcG,MACrCnC,KAAKoC,gBAAgBF,GASjCG,SAASxB,EAAQyB,GACb,MAAO,CACHC,KAAM1B,EAAOG,MAAMQ,MAAMe,KACzBC,WAAY3B,EAAO2B,WACnBC,UAAW5B,EAAO4B,UAClBC,KAAMJ,EAASI,KACfC,OAAQL,EAASK,QAMzBnC,qBAAqBH,EAAWuC,GAC5B,MAAM5B,EAAQX,EAAUW,MAClBH,EAASb,KAAKC,QACpB,IAAKY,IAAWG,EACZ,OAEJ,MAAM6B,EAAQ7B,EAAM8B,YAAYF,GAChC,IAAKC,EACD,OAEJ,MAAM,MAAEE,EAAK,IAAEC,EAAG,MAAExB,GAAUqB,EACxBI,EAAqBpC,EAAOqC,YAAYrC,EAAOsC,qBAErDtC,EAAOG,MAAMoC,YAAYC,aAAaN,EAAOC,EAAKxB,GAC9CyB,GAAsBD,GAAOC,GAAsBF,GACnDlC,EAAOyC,kBAAkBzC,EAAO0C,cAAcR,EAAQvB,EAAMgC,SAMpEpB,gBAAgBF,GAEZ,IAAKlC,KAAKK,UAAUW,MAChB,OAGJ,GAAIhB,KAAKK,UAAUW,MAAMyC,SACrB,OAEJ,MAAM5C,EAASb,KAAKC,QAChBY,GACAb,KAAK0D,aAAa7C,EAAOsC,qBAAqBQ,OAAMC,IAChDC,QAAQC,KAAK,wBAAyBF,MA2BlDrC,sBACI,MAAMP,EAAQhB,KAAKK,UAAUW,MACvBH,EAASb,KAAKC,QACpB,IAAKY,EACD,OAEJ,MAAMI,EAAOJ,EAAOI,KAEpB,IAAKD,EAGD,OAFAhB,KAAKE,UAAW,OAChBe,EAAKC,UAAUC,OAAOxB,GAK1B,GAAIqB,EAAM+C,YACN,OAEJ,MAAMzB,EAAWzB,EAAOsC,oBAClBT,EAAO7B,EAAOmD,QAAQ1B,EAASI,MACrC,IAAKA,EAID,OAHA1C,KAAKE,UAAW,EAChBc,EAAMU,OAAM,QACZT,EAAKC,UAAUC,OAAOxB,GAG1B,MAAM,MAAEoD,EAAK,IAAEC,GAAQnC,EAAOoD,eAE9B,OAAIlB,EAAMJ,SAAWK,EAAIL,QAAUI,EAAML,OAASM,EAAIN,MAOlDA,EAAKwB,MAAM,EAAG5B,EAASK,QAAQwB,MAAM,UANrCnE,KAAKE,UAAW,EAChBc,EAAMU,OAAM,QACZT,EAAKC,UAAUC,OAAOxB,KAWrBK,KAAKE,WACNF,KAAKE,UAAW,EAChBe,EAAKC,UAAUkD,IAAIzE,SAGvBqB,EAAMqD,mBAAmBrE,KAAKqC,SAASxB,EAAQA,EAAOsC,uBAK1D1B,gBACI,MAAMT,EAAQhB,KAAKK,UAAUW,MAC7B,IAAKA,IAAUhB,KAAKE,SAChB,OAGJ,MAAMW,EAASb,KAAKa,OACpB,IAAKA,EACD,OAEJ,MAAM,MAAEkC,EAAK,IAAEC,GAAQnC,EAAOoD,eAC1BlB,EAAMJ,SAAWK,EAAIL,QAAUI,EAAML,OAASM,EAAIN,MAItD1B,EAAMsD,iBAAiBtE,KAAKqC,SAASxB,EAAQA,EAAOsC,sBAKxDzC,oBAAoBL,GAEZA,EAAUU,YAAcV,EAAUkE,SAC9BvE,KAAKC,UACLD,KAAKC,QAAQgB,KAAKC,UAAUC,OAAOvB,GACnCI,KAAKC,QAAQuE,SAKjBxE,KAAKC,SACLD,KAAKC,QAAQgB,KAAKC,UAAUkD,IAAIxE,GAMxC8D,aAAapB,GACT,MAAMzB,EAASb,KAAKa,OACpB,IAAKA,EACD,OAAOpB,QAAQC,OAAO,IAAI+E,MAAM,qBAEpC,MAAMlC,EAAO1B,EAAOG,MAAMQ,MAAMe,KAC1BmC,EAAS,EAAAC,KAAA,mBAAwB9D,EAAOqC,YAAYZ,GAAWC,GAC/DqC,IAAY5E,KAAKG,SACjB0E,EAAQ7E,KAAKqC,SAASxB,EAAQyB,GAC9BwC,EAAU,CAAEvC,KAAAA,EAAMmC,OAAAA,GACxB,OAAI1E,KAAK+E,6BAA6B/E,KAAKW,YAChCX,KAAKW,WACPpB,MAAMuF,GACNE,MAAKC,IAEN,GADAjF,KAAKkF,UAAUN,EAASE,IACnBG,EACD,MAAM,IAAIR,MAAM,oBAAoBK,KAExC9E,KAAKmF,mBAAmBN,EAAOI,MAE9BtB,OAAMnE,IACPQ,KAAKoF,gBAGNpF,KAAKW,WACPpB,MAAMuF,GACNE,MAAKC,IAEN,GADAjF,KAAKkF,UAAUN,EAASE,IACnBG,EACD,MAAM,IAAIR,MAAM,oBAAoBK,KAExC9E,KAAKqF,SAASR,EAAOI,MAEpBtB,OAAMnE,IACPQ,KAAKoF,gBAGbL,6BAA6BnE,GACzB,OAAQA,EACH0E,eAAiBzF,EAAkB0F,6BAE5CL,UAAUN,EAASE,GACf,GAAI9E,KAAKe,WACL,MAAM,IAAI0D,MAAM,uBAGpB,GAAIG,IAAY5E,KAAKG,SACjB,MAAM,IAAIsE,MAAM,yCAMxBe,aAAaX,EAAO9B,EAAOC,GACvB,MAAMhC,EAAQhB,KAAKK,UAAUW,MACvBuB,EAAOsC,EAAMtC,KACnB,OAAKvB,GAILA,EAAMyC,SAAWoB,EAEjB7D,EAAMyE,OAAS,CACX1C,MAAO,EAAA4B,KAAA,mBAAwB5B,EAAOR,GACtCS,IAAK,EAAA2B,KAAA,mBAAwB3B,EAAKT,IAE/BvB,GATI,KAkBfqE,SAASR,EAAOI,GACZ,MAAMjE,EAAQhB,KAAKwF,aAAaX,EAAOI,EAAMlC,MAAOkC,EAAMjC,KAC1D,IAAKhC,EACD,OAGJ,MAAM0E,EAAU,GACVC,EAAW,IAAIC,IAAIX,EAAMS,SAAW,IACtCT,EAAMS,SACNC,EAASE,SAAQ1B,IACbuB,EAAQI,KAAK3B,MASrB,MACM4B,GADWd,EAAMe,UAAY,IACZC,4BACjBC,EAAU,GACZH,GACAA,EAAMF,SAASM,IAIX,MAAM5D,EAAO4D,EAAK5D,KACZJ,EAAOgE,EAAKhE,KACdwD,EAASS,IAAI7D,IAAkB,cAATJ,IACtB+D,EAAQ3D,GAAQJ,MAK5BnB,EAAMqF,WAAWX,EAASQ,GAS9Bf,mBAAmBN,EAAOI,GACtB,MAAMjE,EAAQhB,KAAKwF,aAAaX,EAAOI,EAAMlC,MAAOkC,EAAMjC,KACrDhC,GAGDA,EAAMsF,oBACNtF,EAAMsF,mBAAmBrB,EAAMsB,OAMvCnB,aACI,MAAMpE,EAAQhB,KAAKK,UAAUW,MACzBA,GACAA,EAAMU,OAAM,KAOxB,SAAW7B,GAKP,IAAIkC,EAJJlC,EAAkB0F,6BAA+B,wBAKjD,SAAWxD,GAKPA,EAAIC,cAAgB,IAAI,EAAAwE,QAAQ,kBALpC,CAOGzE,EAAMlC,EAAkBkC,MAAQlC,EAAkBkC,IAAM,KAb/D,CAcGlC,IAAsBA,EAAoB,KC9atC,MAAM4G,UAAwB,EAAAnH,cAMjCQ,YAAYC,GACR2G,QACA1G,KAAK2G,SAAW5G,EAAQ6G,QAO5BC,YAAY/B,GACR,IAAIgC,EACJ,MAAMC,EAAkC,QAAxBD,EAAK9G,KAAK2G,gBAA6B,IAAPG,OAAgB,EAASA,EAAGC,OAC5E,IAAKA,EACD,MAAM,IAAItC,MAAM,qCAEpB,MAAMuC,EAAW,CACbC,KAAMnC,EAAQvC,KACd2E,WAAYpC,EAAQJ,QAGlByC,SADYJ,EAAOK,gBAAgBJ,IACpBK,QACrB,GAAwB,OAApBF,EAASG,OACT,MAAM,IAAI7C,MAAM,mDAEpB,MAAO,CACH1B,MAAOoE,EAASI,aAChBvE,IAAKmE,EAASK,WACd9B,QAASyB,EAASzB,QAClBM,SAAUmB,EAASnB,WClCxB,MAAMyB,UAAyB,EAAAnI,cAMlCQ,YAAYC,GACR2G,QACA1G,KAAKC,QAAUF,EAAQc,OAO3BtB,MAAMuF,GACF,OAAK9E,KAAKC,QAGH,IAAIR,SAAQiI,IACfA,EAAQC,EAAQC,YAAY5H,KAAKC,aAH1BR,QAAQC,OAAO,cAUlC,IAAIiI,ECCA,GDAJ,SAAWA,GAuBPA,EAAQC,YAlBR,SAAqB/G,GAEjB,MAAM4E,EAAS5E,EAAOsC,oBAChB0E,EAAQhH,EAAOiH,oBAAoBrC,GAEnCsC,EAkBV,SAA6BF,EAAOhH,GAIhC,OAHmBA,EAAOmH,YAGRC,QAAOC,GAAsC,IAAjCA,EAAE1G,MAAM2G,QAAQN,EAAMrG,QAAgB0G,EAAE1G,QAAUqG,EAAMrG,QAtBpE4G,CAAoBP,EAAOhH,GAGvCwH,EAAiBN,EAAUE,QAAOC,GAAKA,EAAE/F,OAAMmG,KAAIJ,GAAKA,EAAE1G,QAE1DkE,EAAU6C,MAAMC,KAAK,IAAI5C,IAAIyC,IACnC,MAAO,CACHtF,MAAO8E,EAAMnD,OACb1B,IAAK6E,EAAMnD,OAASmD,EAAMrG,MAAMgC,OAChCkC,QAAAA,EACAM,SAAU,KApBtB,CAkCG2B,IAAYA,EAAU,KC5DlB,MAAMc,UAA4B,EAAAnJ,cAMrCQ,YAAYC,GACR2G,QACA1G,KAAK0I,QAAU,IAAIjC,EAAgB1G,GACnCC,KAAK2I,SAAW,IAAIlB,EAAiB1H,GAOzCR,MAAMuF,GACF,OAAOrF,QAAQmJ,IAAI,CACf5I,KAAK0I,QAAQnJ,MAAMuF,GACnB9E,KAAK2I,SAASpJ,MAAMuF,KACrBE,MAAK,EAAE+B,EAAQ8B,KAAa,EAAQC,aAAa/B,EAAQ8B,OAOpE,SAAWlB,GAuCPA,EAAQmB,aAvBR,SAAsB/B,EAAQ8B,GAE1B,GAA8B,IAA1B9B,EAAOrB,QAAQlC,OACf,OAAOqF,EAEN,GAA+B,IAA3BA,EAAQnD,QAAQlC,OACrB,OAAOuD,EAGX,MAAMrB,EAAUqB,EAAOrB,QAAQxB,QAEzB6E,EAAOrD,EAAQsD,QAAO,CAACC,EAAKrG,KAC9BqG,EAAIrG,GAAO,KACJqG,IACR,IAOH,OALAJ,EAAQnD,QAAQG,SAAQ1B,IACdA,KAAS4E,GACXrD,EAAQI,KAAK3B,MAGd+E,OAAOC,OAAOD,OAAOC,OAAO,GAAIpC,GAAS,CAAErB,QAAAA,KArC1D,CAwCG,IAAY,EAAU,K,IC8UrB,E,sBAjZG,MAAM0D,EACTtJ,cACIE,KAAKqJ,SAAW,KAChBrJ,KAAKsJ,QAAU,KACftJ,KAAKI,aAAc,EACnBJ,KAAKuJ,iBAAmB,GACxBvJ,KAAKwJ,SAAW,GAChBxJ,KAAKyJ,UAAY,KACjBzJ,KAAK0J,OAAS,GACd1J,KAAK2J,cAAe,EACpB3J,KAAK4J,SAAW,GAChB5J,KAAK6J,cAAgB,GACrB7J,KAAK8J,cAAgB,IAAI,EAAAlI,OAAO5B,MAKhC+J,mBACA,OAAO/J,KAAK8J,cAKZrG,eACA,OAAOzD,KAAKyJ,UAEZhG,aAAS3C,GACSd,KAAKyJ,YAAc3I,GAChCd,KAAKyJ,WACF3I,GACA,EAAAkJ,QAAA,UAAkBlJ,EAAUd,KAAKyJ,aAIzCzJ,KAAKiK,SAELjK,KAAKqJ,SAAWrJ,KAAKyJ,UAAY3I,EACjCd,KAAK8J,cAAcI,UAAKC,IAKxBC,cACA,OAAOpK,KAAKqJ,SAEZe,YAAQtJ,GAGR,GAFkBd,KAAKqJ,WAAavI,GAC/Bd,KAAKqJ,UAAYvI,GAAY,EAAAkJ,QAAA,UAAkBlJ,EAAUd,KAAKqJ,UAE/D,OAEJ,MAAM5F,EAAWzD,KAAKyJ,UAGtB,IAAKhG,EACD,OAEJ,MAAMgC,EAASzF,KAAKsJ,QAIpB,IAAK7D,EACD,OAEJ,MAAM2E,EAAWpK,KAAKqJ,SAAWvI,EACjC,IAAKsJ,EAED,YADApK,KAAK8J,cAAcI,UAAKC,GAG5B,MAAME,EAAe5G,EAASlB,KAAK+H,MAAM,MAAM7G,EAASf,MAClD6H,EAAcH,EAAQ7H,KAAK+H,MAAM,MAAMF,EAAQ1H,MAGrD,IAAK1C,KAAK2J,cAAgBY,EAAY/G,OAAS6G,EAAa7G,OAExD,YADAxD,KAAK0B,OAAM,GAGf,MAAM,MAAEqB,EAAK,IAAEC,GAAQyC,EAEvB,IAAI+E,EAAQJ,EAAQ7H,KAAKkI,UAAU1H,GAEnC,MAAM2H,EAASjH,EAASlB,KAAKkI,UAAUzH,GACvCwH,EAAQA,EAAMC,UAAU,EAAGD,EAAMG,YAAYD,IAC7C1K,KAAK0J,OAASc,EACdxK,KAAK8J,cAAcI,UAAKC,GAKxB1E,aACA,OAAOzF,KAAKsJ,QAEZ7D,WAAO3E,GAGFd,KAAKyD,WAGVzD,KAAKsJ,QAAUxI,GAKf0J,YACA,OAAOxK,KAAK0J,OAEZc,UAAM1J,GACNd,KAAK0J,OAAS5I,EAKdiD,kBACA,OAAO/D,KAAK2J,aAEZ5F,gBAAYjD,GACZd,KAAK2J,aAAe7I,EAKpBC,iBACA,OAAOf,KAAKI,YAKhBuB,UAEQ3B,KAAKI,cAGTJ,KAAKI,aAAc,EACnB,EAAAwB,OAAA,UAAiB5B,OAQrB4K,kBACI,IAAIJ,EAAQxK,KAAK0J,OACjB,OAAIc,EACOxK,KAAK6K,QAAQL,GAEjBxK,KAAKuJ,iBAMhBjD,mBAAmBxF,GACX,EAAAkJ,QAAA,UAAkBlJ,EAAUd,KAAKuJ,oBAGrCvJ,KAAKuJ,iBAAmBzI,EACxBd,KAAK6J,cAAgB,EAAQiB,+BAA+B9K,KAAKuJ,kBACjEvJ,KAAK8J,cAAcI,UAAKC,IAS5B5D,QACI,OAAOvG,KAAK+K,UAKhBhL,UACI,OAAO,IAAAiL,MAAKhL,KAAKwJ,UAYrBtD,UACI,OAAOlG,KAAK4J,SAehBqB,eACI,OAAOjL,KAAK6J,cAKhBxD,WAAWvF,EAAUoF,GACjB,MAAMgF,GAAS,IAAAC,SAAQrK,GAAY,IAC7BiF,EAAQG,GAAW,GACrB,EAAA8D,QAAA,UAAkBkB,EAAQlL,KAAKwJ,WAC/B,EAAAQ,QAAA,UAAkBjE,EAAO/F,KAAK4J,YAG9BsB,EAAO1H,QACPxD,KAAKwJ,SAAW0B,EAChBlL,KAAK4J,SAAW7D,EAChB/F,KAAK6J,cAAgB,EAAQuB,iBAAiBrF,KAG9C/F,KAAKwJ,SAAW,GAChBxJ,KAAK4J,SAAW,GAChB5J,KAAK6J,cAAgB,IAEzB7J,KAAK8J,cAAcI,UAAKC,IAK5B9F,mBAAmBgH,GAEf,IAAKrL,KAAKyJ,UACN,OAEJ,MAAM,OAAE9G,EAAM,KAAED,GAAS2I,GACnB,QAAEjB,EAAO,SAAE3G,GAAazD,KAC9B,IAAKyD,EACD,OAIJ,GAAIf,IAASe,EAASf,KAElB,YADA1C,KAAK0B,OAAM,GAKf,GAAIiB,EAASc,EAASd,OAElB,YADA3C,KAAK0B,OAAM,GAGf,MAAM,OAAE+D,GAAWzF,KACnB,IAAKyF,IAAW2E,EACZ,OAIJ,MAAMkB,EAAc7F,EAAOzC,IAAMyC,EAAO1C,MAClCsH,EAAe5G,EAASlB,KAAK+H,MAAM,MAAM7G,EAASf,MAElD6I,EADcnB,EAAQ7H,KAAK+H,MAAM,MAAMF,EAAQ1H,MACtBc,OAAS6G,EAAa7G,OACjDb,EAASc,EAASd,OAAS2I,EAAcC,GACzCvL,KAAK0B,OAAM,GAOnB4C,iBAAiB+G,GACb,MAAM5H,EAAWzD,KAAKyJ,UAEtB,IAAKhG,EACD,OAEJ,MAAM,KAAElB,EAAI,OAAEI,EAAM,KAAED,GAAS2I,EACzBG,EAAOjJ,EAAK+H,MAAM,MAAM5H,GAAMC,EAAS,GAGxC6I,GAAQA,EAAKrH,MAAM,OAAUkH,EAAO1I,QAAUc,EAASd,OACxD3C,KAAKoK,QAAUiB,EAInBrL,KAAK0B,OAAM,GASfoB,YAAYD,GACR,MAAMY,EAAWzD,KAAKyJ,UAChBhE,EAASzF,KAAKsJ,QACdc,EAAUpK,KAAKqJ,SACrB,IAAK5F,IAAagC,IAAW2E,EACzB,OAEJ,IAAI,MAAErH,EAAK,IAAEC,GAAQyC,EAIrB,OADAzC,GAAaoH,EAAQ7H,KAAKiB,OAASC,EAASlB,KAAKiB,OAC1C,CAAET,MAAAA,EAAOC,IAAAA,EAAKxB,MAAOqB,GAOhCnB,MAAM+J,GAAO,IAIJA,GAAQzL,KAAK2J,eAGlB3J,KAAKiK,SACLjK,KAAK8J,cAAcI,UAAKC,IAM5BU,QAAQL,GACJ,MAAMjE,EAAQvG,KAAKuJ,iBACnB,IAAImC,EAAU,GACd,IAAK,IAAIvF,KAAQI,EAAO,CAKpB,MAAMoF,EAAQxF,EAAKyF,MAAMzD,QAAQ,KAC3B0D,EAASF,GAAS,EAAIxF,EAAKyF,MAAMnB,UAAU,EAAGkB,GAASxF,EAAKyF,MAClE,IAAIzH,EAAQ,EAAA2H,UAAA,kBAA4BD,EAAQrB,GAEhD,GAAIrG,EAAO,CAEP,IAAI4H,EAAS,EAAAD,UAAA,UAAoB3F,EAAKyF,MAAOzH,EAAM6H,QAAS,EAAQC,MACpEP,EAAQ5F,KAAKoD,OAAOC,OAAOD,OAAOC,OAAO,GAAIhD,GAAO,CAEhD+F,cAAe/F,EAAK+F,cAAeN,MAAOG,EAAOI,KAAK,IAGtDC,WAAYjG,EAAKiG,WAAajG,EAAKiG,WAAajG,EAAKyF,MAAOS,MAAOlI,EAAMkI,UASrF,OANAX,EAAQY,KAAK,EAAQC,WAGrBb,EAAQ7F,SAAQ2G,WACLA,EAAEH,SAENX,EAKXX,UACI,MAAMhL,EAAUC,KAAKwJ,UAAY,GAC3BgB,EAAQxK,KAAK0J,OACnB,IAAKc,EACD,OAAO,IAAAlC,KAAIvI,GAAS0M,IAAU,CAAGC,IAAKD,EAAQlK,KAAMkK,MAExD,MAAMf,EAAU,GAChB,IAAK,MAAMe,KAAU1M,EAAS,CAC1B,MAAMoE,EAAQ,EAAA2H,UAAA,kBAA4BW,EAAQjC,GAClD,GAAIrG,EAAO,CACP,MAAM4H,EAAS,EAAAD,UAAA,UAAoBW,EAAQtI,EAAM6H,QAAS,EAAQC,MAClEP,EAAQ5F,KAAK,CACT4G,IAAKD,EACLJ,MAAOlI,EAAMkI,MACb9J,KAAMwJ,EAAOI,KAAK,OAI9B,OAAO,IAAA7D,KAAIoD,EAAQY,KAAK,EAAQK,WAAWC,IAAU,CACjDrK,KAAMqK,EAAOrK,KACbmK,IAAKE,EAAOF,QAMpBzC,SACIjK,KAAKqJ,SAAW,KAChBrJ,KAAKsJ,QAAU,KACftJ,KAAKuJ,iBAAmB,GACxBvJ,KAAKwJ,SAAW,GAChBxJ,KAAKyJ,UAAY,KACjBzJ,KAAK0J,OAAS,GACd1J,KAAK2J,cAAe,EACpB3J,KAAK4J,SAAW,GAChB5J,KAAK6J,cAAgB,KAO7B,SAAWlC,GAIP,MAAMkF,EAAc,CAAC,WAAY,WAAY,QAAS,SAAU,WAI1DC,EAAYD,EAAY7D,QAAO,CAACC,EAAK9G,KACvC8G,EAAI9G,GAAQ,KACL8G,IACR,IAOHtB,EAAQsE,KAHR,SAAczK,GACV,MAAO,SAASA,YAiBpBmG,EAAQgF,SAPR,SAAkBI,EAAGC,GACjB,MAAMC,EAAQF,EAAEV,MAAQW,EAAEX,MAC1B,OAAc,IAAVY,EACOA,EAEJF,EAAEL,IAAIQ,cAAcF,EAAEN,MAkBjC/E,EAAQ4E,UARR,SAAmBQ,EAAGC,GAClB,IAAIlG,EAAIqG,EAAIC,EACZ,MAAMH,EAAQF,EAAEV,MAAQW,EAAEX,MAC1B,OAAc,IAAVY,EACOA,EAE0I,QAA7IG,EAA6B,QAAvBtG,EAAKiG,EAAEX,kBAA+B,IAAPtF,OAAgB,EAASA,EAAGoG,cAAsC,QAAvBC,EAAKH,EAAEZ,kBAA+B,IAAPe,EAAgBA,EAAK,WAAwB,IAAPC,EAAgBA,EAAK,GA2BtLzF,EAAQmD,+BAbR,SAAwCvE,GACpC,MAAM8G,EAAa,IAAIzH,IACvBW,EAAMV,SAAQM,KACNA,EAAKhE,MACJ0K,EAAYS,SAASnH,EAAKhE,OAC1BkL,EAAWjH,IAAID,EAAKhE,OACrBkL,EAAWjJ,IAAI+B,EAAKhE,SAG5B,MAAMoL,EAAWhF,MAAMC,KAAK6E,GAE5B,OADAE,EAASjB,MAAK,CAACS,EAAGC,IAAMD,EAAEG,cAAcF,KACjCH,EAAYW,OAAOD,IAoB9B5F,EAAQyD,iBAPR,SAA0BlF,GACtB,MAAMuH,EAAWvE,OAAOwE,KAAKxH,GACxBoC,KAAIqF,GAAOzH,EAAQyH,KACnB1F,QAAQzG,KAAYA,KAAWA,KAASsL,KACxCR,MAAK,CAACS,EAAGC,IAAMD,EAAEG,cAAcF,KACpC,OAAOH,EAAYW,OAAOC,IA1FlC,CA6FG,IAAY,EAAU,K,qCC5ezB,MAAMG,EAAa,oBAIbC,EAAe,gBAYfC,GAAc,EAeb,MAAMC,UAAkB,EAAAC,OAI3BlO,YAAYC,GACR2G,MAAM,CAAEuH,KAAMC,SAASC,cAAc,SACrCnO,KAAKoO,aAAe,EACpBpO,KAAKC,QAAU,KACfD,KAAKqO,OAAS,KACdrO,KAAKsO,YAAa,EAClBtO,KAAKuO,UAAY,IAAI,EAAA3M,OAAO5B,MAC5BA,KAAKwO,mBAAqB,IAAI,EAAA5M,OAAO5B,MACrCA,KAAKyO,cAAgB,IAAI,EAAA7M,OAAO5B,MAChCA,KAAK0O,iBAAmB,GACxB1O,KAAK2O,UAAY5O,EAAQ6O,UAAYb,EAAUc,gBAC/C7O,KAAKgB,MAAQjB,EAAQiB,OAAS,KAC9BhB,KAAKa,OAASd,EAAQc,QAAU,KAChCb,KAAK8O,SAAS,gBAKdC,kBACA,OAAO/O,KAAKoO,aAKZvN,aACA,OAAOb,KAAKC,QAEZY,WAAOC,GACPd,KAAKC,QAAUa,EAKfR,eACA,OAAON,KAAKuO,UASZ9N,wBACA,OAAOT,KAAKwO,mBAKZQ,mBACA,OAAOhP,KAAKyO,cAKZzN,YACA,OAAOhB,KAAKqO,OAEZrN,UAAMA,IACAA,GAAUhB,KAAKqO,SAAWrN,IAAUhB,KAAKqO,SAG3CrO,KAAKqO,QACLrO,KAAKqO,OAAOtE,aAAazI,WAAWtB,KAAKiP,oBAAqBjP,MAElEA,KAAKqO,OAASrN,EACVhB,KAAKqO,QACLrO,KAAKqO,OAAOtE,aAAaxJ,QAAQP,KAAKiP,oBAAqBjP,OAMnE2B,UACI3B,KAAKqO,OAAS,KACd3H,MAAM/E,UAYVuN,YAAYC,GACR,IAAInP,KAAKuE,UAAavE,KAAKC,QAG3B,OAAQkP,EAAMhN,MACV,IAAK,UACDnC,KAAKoP,YAAYD,GACjB,MACJ,IAAK,YACDnP,KAAKqP,cAAcF,GACnB,MACJ,IAAK,SACDnP,KAAKsP,WAAWH,IAS5BzN,QACI1B,KAAKoO,aAAe,EACpBpO,KAAK0O,iBAAmB,GACpB1O,KAAKqO,QACLrO,KAAKqO,OAAO3M,OAAM,GAM1B6N,eACI,MAAMC,EAASxP,KAAKiO,KAAKwB,cAAc,kBAClCD,GAILxP,KAAKuO,UAAUrE,KAAKsF,EAAOE,aAAa,eACxC1P,KAAK0B,SAJD1B,KAAK0B,QASbiO,cAAczN,GACVgM,SAAS0B,iBAAiB,UAAW5P,KAAM8N,GAC3CI,SAAS0B,iBAAiB,YAAa5P,KAAM8N,GAC7CI,SAAS0B,iBAAiB,SAAU5P,KAAM8N,GAK9C+B,eAAe3N,GACXgM,SAAS4B,oBAAoB,UAAW9P,KAAM8N,GAC9CI,SAAS4B,oBAAoB,YAAa9P,KAAM8N,GAChDI,SAAS4B,oBAAoB,SAAU9P,KAAM8N,GAKjDmB,sBACQjP,KAAK+P,aACL/P,KAAKoO,aAAe,EACpBpO,KAAKyO,cAAcvE,KAAKlK,KAAKoO,cAC7BpO,KAAKgQ,UAMbC,gBAAgB/N,GACZ,MAAMlB,EAAQhB,KAAKqO,OACnB,IAAKrN,EACD,OAEJ,GAAIhB,KAAKsO,WAML,OALAtO,KAAKsO,YAAa,OACbtO,KAAKuE,WACNvE,KAAKkQ,OACLlQ,KAAKwO,mBAAmBtE,UAAKC,KAIrC,IAAI8D,EAAO,KACPkC,EAAqBnP,EAAM4J,iBAAmB5J,EAAM4J,kBAOxD,GALIqD,EADAkC,GAAsBA,EAAmB3M,OAClCxD,KAAKoQ,0BAA0BpP,EAAOmP,GAGtCnQ,KAAKqQ,iBAAiBrP,IAE5BiN,EACD,OAESA,EAAKqC,iBAAiB,IAAI1C,KAAc5N,KAAKoO,cACnDlN,UAAUkD,IAAIyJ,GAErB,IAAI0C,EAAWrC,SAASC,cAAc,OACtCoC,EAASC,UAAY,wBACrBvC,EAAKwC,YAAYF,GACjBvQ,KAAK0Q,kBAGA1P,EAAMwJ,QACWxK,KAAK2Q,kBAMvB3Q,KAAKuE,UACLvE,KAAK4Q,OACL5Q,KAAK6Q,eACL7Q,KAAKwO,mBAAmBtE,UAAKC,IAG7BnK,KAAK6Q,eAVD7Q,KAAKgQ,SAajBI,0BAA0BpP,EAAOuF,GAE7B,IAAKA,EAAM/C,OAOP,OANAxD,KAAKsO,YAAa,EAClBtO,KAAK0B,QACA1B,KAAKuE,WACNvE,KAAKkQ,OACLlQ,KAAKwO,mBAAmBtE,UAAKC,IAE1B,KAGX,IAAI8D,EAAOjO,KAAKiO,KAChBA,EAAK6C,YAAc,GAGnB,IAAI7F,EAAejK,EAAMiK,eAErB8F,EAAK7C,SAASC,cAAc,MAChC4C,EAAGP,UAAY,oBACf,IAAK,IAAIrK,KAAQI,EAAO,CACpB,IAAKvG,KAAK2O,UAAUqC,yBAChB,OAAO,KAEX,IAAIC,EAAKjR,KAAK2O,UAAUqC,yBAAyB7K,EAAM8E,GACvD8F,EAAGN,YAAYQ,GAGnB,OADAhD,EAAKwC,YAAYM,GACV9C,EAEXoC,iBAAiBrP,GACb,MAAMuF,GAAQ,IAAA4E,SAAQnK,EAAMuF,SAE5B,IAAKA,IAAUA,EAAM/C,OAOjB,OANAxD,KAAKsO,YAAa,EAClBtO,KAAK0B,QACA1B,KAAKuE,WACNvE,KAAKkQ,OACLlQ,KAAKwO,mBAAmBtE,UAAKC,IAE1B,KAMX,MAAMpK,GAAU,IAAAoL,SAAQnK,EAAMjB,WAC9B,GAAuB,IAAnBA,EAAQyD,OAGR,OAFAxD,KAAKuO,UAAUrE,KAAKnK,EAAQ,IAC5BC,KAAK0B,QACE,KAGX,MAAMuM,EAAOjO,KAAKiO,KAClBA,EAAK6C,YAAc,GAGnB,MAAM7F,EAAejK,EAAMiK,eAE3B,IAAI8F,EAAK7C,SAASC,cAAc,MAChC4C,EAAGP,UAAY,oBACf,IAAK,MAAMrK,KAAQI,EAAO,CACtB,MAAM0K,EAAKjR,KAAK2O,UAAUuC,eAAe/K,EAAMnF,EAAMkF,UAAW+E,GAChE8F,EAAGN,YAAYQ,GAGnB,OADAhD,EAAKwC,YAAYM,GACV9C,EAUXkD,OAAOC,GACH,MAAM7K,EAAQvG,KAAKiO,KAAKqC,iBAAiB,IAAI1C,KACvCjC,EAAQ3L,KAAKoO,aACnB,IAAIoB,EAASxP,KAAKiO,KAAKwB,cAAc,kBAErC,GADAD,EAAOtO,UAAUC,OAAO0M,GACN,OAAduD,EACApR,KAAKoO,aAAyB,IAAVzC,EAAcpF,EAAM/C,OAAS,EAAImI,EAAQ,OAE5D,GAAkB,SAAdyF,EACLpR,KAAKoO,aAAezC,EAAQpF,EAAM/C,OAAS,EAAImI,EAAQ,EAAI,MAE1D,CAED,MAAM0F,EAAYrR,KAAKiO,KAAKqD,wBAAwBC,OAC9CC,EAAahC,EAAO8B,wBAAwBC,OAC5CE,EAAaC,KAAKC,MAAMN,EAAYG,GAGtCxR,KAAKoO,aADS,WAAdgD,EACoBzF,EAAQ8F,EAGR9F,EAAQ8F,EAGhCzR,KAAKoO,aAAesD,KAAKE,IAAIF,KAAKG,IAAI,EAAG7R,KAAKoO,cAAe7H,EAAM/C,OAAS,GAEhFgM,EAASjJ,EAAMvG,KAAKoO,cACpBoB,EAAOtO,UAAUkD,IAAIyJ,GACrB,IAAIxF,EAAiBrI,KAAKiO,KAAKwB,cAAc,sBAC7C,EAAAqC,WAAA,uBAAkCzJ,EAAgBmH,GAClDxP,KAAKyO,cAAcvE,KAAKlK,KAAKoO,cAC7BpO,KAAK0Q,kBAKTtB,YAAYD,GACR,IAAInP,KAAKuE,UAAavE,KAAKC,QAG3B,GAAKD,KAAKC,QAAQgB,KAAK8Q,SAAS5C,EAAM6C,QAItC,OAAQ7C,EAAM8C,SACV,KAAK,EAAG,CAEJ9C,EAAM+C,iBACN/C,EAAMgD,kBACNhD,EAAMiD,2BACN,MAAMpR,EAAQhB,KAAKqO,OACnB,IAAKrN,EACD,OAGJ,MAAMuF,EAAQvF,EAAM4J,iBAAmB5J,EAAM4J,kBAC7C,GAAIrE,GAA0B,IAAjBA,EAAM/C,OAGf,OAFAxD,KAAKuO,UAAUrE,KAAK3D,EAAM,GAAG6F,YAAc7F,EAAM,GAAGqF,YACpD5L,KAAK0B,QAGT,MAAM2Q,EAAYrS,KAAK2Q,kBAiBvB,OAXI3P,EAAMwJ,OAASxJ,EAAMwJ,OAASxK,KAAK0O,mBACnC1N,EAAM+C,aAAc,EACpB/D,KAAKuO,UAAUrE,KAAKlJ,EAAMwJ,OAC1BxJ,EAAM+C,aAAc,EACpB/D,KAAK0O,iBAAmB1N,EAAMwJ,OAG9B6H,GACArS,KAAKgQ,cAEThQ,KAAKmR,OAAOhC,EAAMmD,SAAW,KAAO,QAGxC,KAAK,GAKD,OAJAnD,EAAM+C,iBACN/C,EAAMgD,kBACNhD,EAAMiD,gCACNpS,KAAK0B,QAET,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GAAI,CAELyN,EAAM+C,iBACN/C,EAAMgD,kBACNhD,EAAMiD,2BACN,MAAMG,EAAQ,EAAQC,WAAWrD,EAAM8C,SAEvC,YADAjS,KAAKmR,OAAOoB,GAGhB,QACI,YA1DJvS,KAAK0B,QAgEb2N,cAAcF,GACV,GAAInP,KAAKuE,WAAavE,KAAKC,QACvB,OAEJ,GAAI,EAAQwS,iBAAiBtD,GAEzB,YADAnP,KAAK0B,QAGT,IAAIsQ,EAAS7C,EAAM6C,OACnB,KAAOA,IAAW9D,SAASwE,iBAAiB,CAExC,GAAIV,EAAO9Q,UAAU6Q,SAASnE,GAM1B,OALAuB,EAAM+C,iBACN/C,EAAMgD,kBACNhD,EAAMiD,2BACNpS,KAAKuO,UAAUrE,KAAK8H,EAAOtC,aAAa,oBACxC1P,KAAK0B,QAIT,GAAIsQ,IAAWhS,KAAKiO,KAIhB,OAHAkB,EAAM+C,iBACN/C,EAAMgD,uBACNhD,EAAMiD,2BAGVJ,EAASA,EAAOW,cAEpB3S,KAAK0B,QAKT4N,WAAWH,GACP,GAAInP,KAAKuE,WAAavE,KAAKC,QACvB,OAEJ,MAAM,KAAEgO,GAASjO,KAIbiO,EAAK8D,SAAS5C,EAAM6C,SAIxBY,uBAAsB,KAClB5S,KAAK6Q,kBAQbF,kBACI,MAAM,MAAE3P,GAAUhB,KAClB,IAAKgB,EACD,OAAO,EAEX,MAAMuF,EAAQvG,KAAKiO,KAAKqC,iBAAiB,IAAI1C,KACvCiF,EAAS,EAAQC,aAAa,EAAQC,WAAWxM,KACjD,MAAEiE,GAAUxJ,EAElB,SAAI6R,GAAUA,IAAWrI,GAAmC,IAA1BqI,EAAO1K,QAAQqC,KAC7CxJ,EAAMwJ,MAAQqI,EACP,IAOfhC,eACI,MAAM,KAAE5C,GAASjO,KACXgB,EAAQhB,KAAKqO,OACbxN,EAASb,KAAKC,QAIpB,KAAKY,GAAWG,GAAUA,EAAMyC,UAAazC,EAAMyE,QAC/C,OAEJ,MAAM1C,EAAQ/B,EAAMyE,OAAO1C,MACrBT,EAAWzB,EAAO0C,cAAcR,GAChCiQ,EAASnS,EAAOoS,yBAAyB3Q,GACzC4Q,EAAQC,OAAOC,iBAAiBnF,GAChCoF,EAAaC,SAASJ,EAAMK,gBAAiB,KAAO,EACpDC,EAAcF,SAASJ,EAAMM,YAAa,KAAO,EAEvD,EAAAC,SAAA,YAAqB,CACjBT,OAAAA,EACA/R,KAAMJ,EAAOI,KACbyS,UArfO,IAsfPC,UA1fO,GA2fP1F,KAAMA,EACNvJ,OAAQ,CAAEkP,WAAYP,EAAaG,GACnCK,UAAW,QACXX,MAAOA,IAMfxC,kBACI,IAAI5J,EAAIqG,EACR,IAAIoD,EAAWvQ,KAAKiO,KAAKwB,cAAc,0BACvC,IAAKc,EACD,OAEJ,KAA4B,QAArBzJ,EAAK9G,KAAKgB,aAA0B,IAAP8F,OAAgB,EAASA,EAAG8D,iBAC5D,OAEJ,IAAIrE,EAA8B,QAArB4G,EAAKnN,KAAKgB,aAA0B,IAAPmM,OAAgB,EAASA,EAAGvC,kBACtE,IAAKrE,EAED,YADAgK,EAASuD,aAAa,QAAS,gBAGnC,IAAIC,EAAaxN,EAAMvG,KAAKoO,cAC5B,GAAK2F,EAKL,GADAxD,EAASO,YAAc,GACnBiD,EAAW7H,cAAe,CAC1B,IAAI+B,EAKAA,EAJCjO,KAAK2O,UAAUqF,wBAIThU,KAAK2O,UAAUqF,wBAAwBD,GAHvChG,EAAUc,gBAAgBmF,wBAAwBD,GAK7DxD,EAASE,YAAYxC,GACrBsC,EAASuD,aAAa,QAAS,SAG/BvD,EAASuD,aAAa,QAAS,qBAhB/BvD,EAASuD,aAAa,QAAS,iBAgI3C,IAAI,GA5GJ,SAAW/F,GAIP,MAAMkG,EAIFjD,yBAAyB7K,EAAM8E,GAC3B,IAAIiJ,EAAWlU,KAAKmU,gBAAgBhO,EAAKiG,YAAcjG,EAAKyF,OAI5D,OAHIzF,EAAKiO,YACLF,EAAShT,UAAUkD,IAAI,2BAEpBpE,KAAKqU,eAAeH,EAAUlU,KAAKsU,iBAAiBnO,EAAKyF,SAAUzF,EAAKhE,KAAMgE,EAAKhE,KAAM8I,EAAc9E,EAAKoO,MAKvHrD,eAAe/K,EAAMD,EAAS+E,GAC1B,OAAOjL,KAAKqU,eAAerU,KAAKmU,gBAAgBhO,EAAKuG,KAAM1M,KAAKsU,iBAAiBnO,EAAK5D,OAAQ,EAAAyH,QAAA,UAAkB9D,EAAS,IAAKA,EAAQC,EAAKuG,MAAQ,GAAIzB,GAK3J+I,wBAAwBD,GACpB,IAAIS,EAAMtG,SAASC,cAAc,OAEjC,OADAqG,EAAI1D,YAAciD,EAAW7H,eAAiB,GACvCsI,EAKXL,gBAAgB3S,GACZ,MAAMyP,EAAK/C,SAASC,cAAc,MAIlC,OAHA8C,EAAGT,UAAY5C,EAEfqD,EAAG6C,aAAa,aAActS,GACvByP,EAKXqD,iBAAiB1H,GACb,MAAM6H,EAAYvG,SAASC,cAAc,QAMzC,OALAsG,EAAUjE,UAAY,qBAEtBiE,EAAUC,UAAY,EAAAC,iBAAA,SAA0B/H,EAAQ,CACpDgI,YAAa,CAAC,UAEXH,EAKXJ,eAAepD,EAAIwD,EAAWI,EAAY1S,EAAM8I,EAAcsJ,GAE1D,GAAIA,EAAM,CACN,MAAMO,EAAWP,EAAKQ,QAAQ,CAC1BvE,UAAW,wCAEfS,EAAGR,YAAYqE,QAEd,GAAID,EAAY,CACjB,MAAMG,EAAW9G,SAASC,cAAc,QACxC6G,EAASlE,aAAe3O,EAAK,IAAM,IAAI8S,cACvC,MAAMC,EAAcjK,EAAa9C,QAAQhG,GA5lBxC,GA4lB4D,EAC7D6S,EAASxE,UAAY,0CACrBwE,EAASlB,aAAa,mBAAoBoB,EAAWC,YACrDlE,EAAGR,YAAYuE,OAEd,CAKD,MAAMI,EAAYlH,SAASC,cAAc,QACzCiH,EAAU5E,UAAY,wBACtBS,EAAGR,YAAY2E,GAInB,GAFAnE,EAAGR,YAAYgE,GAEXI,EAAY,CACZ5D,EAAGoE,MAAQlT,EACX,MAAMmT,EAAmBpH,SAASC,cAAc,QAChDmH,EAAiB9E,UAAY,4BAC7B8E,EAAiBxE,YAAc3O,EAAKoT,oBACpCtE,EAAGR,YAAY6E,OAEd,CAID,MAAME,EAAwBtH,SAASC,cAAc,QACrDqH,EAAsBhF,UAAY,4BAClCS,EAAGR,YAAY+E,GAEnB,OAAOvE,GAGflD,EAAUkG,SAAWA,EAIrBlG,EAAUc,gBAAkB,IAAIoF,EAvGpC,CAwGGlG,IAAcA,EAAY,KAK7B,SAAWpG,GAIPA,EAAQ6K,WAAa,CACjB,GAAI,KACJ,GAAI,OACJ,GAAI,SACJ,GAAI,YAuBR7K,EAAQmL,aAlBR,SAAsB5H,GAClB,MAAMuK,EAAMvK,EAAO1H,OACnB,IAAIqP,EAAS,GACb,GAAI4C,EAAM,EACN,OAAO5C,EAEX,MAAM6C,EAASxK,EAAO,GAAG1H,OACzB,IAAK,IAAImS,EAAI,EAAGA,EAAID,EAAQC,IAAK,CAC7B,MAAMC,EAAK1K,EAAO,GAAGyK,GACrB,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAKI,IACrB,GAAI3K,EAAO2K,GAAGF,KAAOC,EACjB,OAAO/C,EAGfA,GAAU+C,EAEd,OAAO/C,GAgBXlL,EAAQoL,WAVR,SAAoBxM,GAChB,MAAM2E,EAAS,GACf,IAAK,IAAIyK,EAAI,EAAGF,EAAMlP,EAAM/C,OAAQmS,EAAIF,EAAKE,IAAK,CAC9C,MAAMG,EAAOvP,EAAMoP,GAAGjG,aAAa,cAC/BoG,GACA5K,EAAOpF,KAAKgQ,GAGpB,OAAO5K,GAaXvD,EAAQ8K,iBAPR,SAA0BtD,GACtB,OAAyB,IAAjBA,EAAM4G,QACV5G,EAAM6G,QACN7G,EAAM8G,SACN9G,EAAMmD,UACNnD,EAAM+G,SAtDlB,CAyDG,IAAY,EAAU,KC1tBlB,MAAMC,EAAqB,IAAI,EAAAC,MAAM","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/dummyconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/handler.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/kernelconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/contextconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/connector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/model.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/widget.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/tokens.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * DummyConnector's fetch method always returns a rejected Promise.\n * This class is only instantiated if both CompletionHandler._connector and\n * CompletionHandler._fetchItems are undefined.\n */\nexport class DummyConnector extends DataConnector {\n    fetch(_) {\n        return Promise.reject('Attempting to fetch with DummyConnector. Please ensure connector responseType is set.');\n    }\n}\n//# sourceMappingURL=dummyconnector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Text } from '@jupyterlab/coreutils';\nimport { Message, MessageLoop } from '@lumino/messaging';\nimport { Signal } from '@lumino/signaling';\nimport { DummyConnector } from './dummyconnector';\n/**\n * A class added to editors that can host a completer.\n */\nconst COMPLETER_ENABLED_CLASS = 'jp-mod-completer-enabled';\n/**\n * A class added to editors that have an active completer.\n */\nconst COMPLETER_ACTIVE_CLASS = 'jp-mod-completer-active';\n/**\n * A completion handler for editors.\n */\nexport class CompletionHandler {\n    /**\n     * Construct a new completion handler for a widget.\n     */\n    constructor(options) {\n        this._editor = null;\n        this._enabled = false;\n        this._pending = 0;\n        this._isDisposed = false;\n        this.completer = options.completer;\n        this.completer.selected.connect(this.onCompletionSelected, this);\n        this.completer.visibilityChanged.connect(this.onVisibilityChanged, this);\n        this._connector = options.connector;\n    }\n    /**\n     * The data connector used to populate completion requests.\n     * @deprecated will be removed, or will return `CompletionHandler.ICompletionItemsConnector`\n     * instead of `IDataConnector` in future versions\n     *\n     * #### Notes\n     * The only method of this connector that will ever be called is `fetch`, so\n     * it is acceptable for the other methods to be simple functions that return\n     * rejected promises.\n     */\n    get connector() {\n        if ('responseType' in this._connector) {\n            return new DummyConnector();\n        }\n        return this._connector;\n    }\n    set connector(connector) {\n        this._connector = connector;\n    }\n    /**\n     * The editor used by the completion handler.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        if (newValue === this._editor) {\n            return;\n        }\n        let editor = this._editor;\n        // Clean up and disconnect from old editor.\n        if (editor && !editor.isDisposed) {\n            const model = editor.model;\n            editor.host.classList.remove(COMPLETER_ENABLED_CLASS);\n            editor.host.classList.remove(COMPLETER_ACTIVE_CLASS);\n            model.selections.changed.disconnect(this.onSelectionsChanged, this);\n            model.value.changed.disconnect(this.onTextChanged, this);\n        }\n        // Reset completer state.\n        this.completer.reset();\n        this.completer.editor = newValue;\n        // Update the editor and signal connections.\n        editor = this._editor = newValue;\n        if (editor) {\n            const model = editor.model;\n            this._enabled = false;\n            model.selections.changed.connect(this.onSelectionsChanged, this);\n            model.value.changed.connect(this.onTextChanged, this);\n            // On initial load, manually check the cursor position.\n            this.onSelectionsChanged();\n        }\n    }\n    /**\n     * Get whether the completion handler is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Invoke the handler and launch a completer.\n     */\n    invoke() {\n        MessageLoop.sendMessage(this, CompletionHandler.Msg.InvokeRequest);\n    }\n    /**\n     * Process a message sent to the completion handler.\n     */\n    processMessage(msg) {\n        switch (msg.type) {\n            case CompletionHandler.Msg.InvokeRequest.type:\n                this.onInvokeRequest(msg);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Get the state of the text editor at the given position.\n     */\n    getState(editor, position) {\n        return {\n            text: editor.model.value.text,\n            lineHeight: editor.lineHeight,\n            charWidth: editor.charWidth,\n            line: position.line,\n            column: position.column\n        };\n    }\n    /**\n     * Handle a completion selected signal from the completion widget.\n     */\n    onCompletionSelected(completer, val) {\n        const model = completer.model;\n        const editor = this._editor;\n        if (!editor || !model) {\n            return;\n        }\n        const patch = model.createPatch(val);\n        if (!patch) {\n            return;\n        }\n        const { start, end, value } = patch;\n        const cursorBeforeChange = editor.getOffsetAt(editor.getCursorPosition());\n        // we need to update the shared model in a single transaction so that the undo manager works as expected\n        editor.model.sharedModel.updateSource(start, end, value);\n        if (cursorBeforeChange <= end && cursorBeforeChange >= start) {\n            editor.setCursorPosition(editor.getPositionAt(start + value.length));\n        }\n    }\n    /**\n     * Handle `invoke-request` messages.\n     */\n    onInvokeRequest(msg) {\n        // If there is no completer model, bail.\n        if (!this.completer.model) {\n            return;\n        }\n        // If a completer session is already active, bail.\n        if (this.completer.model.original) {\n            return;\n        }\n        const editor = this._editor;\n        if (editor) {\n            this._makeRequest(editor.getCursorPosition()).catch(reason => {\n                console.warn('Invoke request bailed', reason);\n            });\n        }\n    }\n    /**\n     * Handle selection changed signal from an editor.\n     *\n     * #### Notes\n     * If a sub-class reimplements this method, then that class must either call\n     * its super method or it must take responsibility for adding and removing\n     * the completer completable class to the editor host node.\n     *\n     * Despite the fact that the editor widget adds a class whenever there is a\n     * primary selection, this method checks independently for two reasons:\n     *\n     * 1. The editor widget connects to the same signal to add that class, so\n     *    there is no guarantee that the class will be added before this method\n     *    is invoked so simply checking for the CSS class's existence is not an\n     *    option. Secondarily, checking the editor state should be faster than\n     *    querying the DOM in either case.\n     * 2. Because this method adds a class that indicates whether completer\n     *    functionality ought to be enabled, relying on the behavior of the\n     *    `jp-mod-has-primary-selection` to filter out any editors that have\n     *    a selection means the semantic meaning of `jp-mod-completer-enabled`\n     *    is obscured because there may be cases where the enabled class is added\n     *    even though the completer is not available.\n     */\n    onSelectionsChanged() {\n        const model = this.completer.model;\n        const editor = this._editor;\n        if (!editor) {\n            return;\n        }\n        const host = editor.host;\n        // If there is no model, return.\n        if (!model) {\n            this._enabled = false;\n            host.classList.remove(COMPLETER_ENABLED_CLASS);\n            return;\n        }\n        // If we are currently performing a subset match,\n        // return without resetting the completer.\n        if (model.subsetMatch) {\n            return;\n        }\n        const position = editor.getCursorPosition();\n        const line = editor.getLine(position.line);\n        if (!line) {\n            this._enabled = false;\n            model.reset(true);\n            host.classList.remove(COMPLETER_ENABLED_CLASS);\n            return;\n        }\n        const { start, end } = editor.getSelection();\n        // If there is a text selection, return.\n        if (start.column !== end.column || start.line !== end.line) {\n            this._enabled = false;\n            model.reset(true);\n            host.classList.remove(COMPLETER_ENABLED_CLASS);\n            return;\n        }\n        // If the part of the line before the cursor is white space, return.\n        if (line.slice(0, position.column).match(/^\\s*$/)) {\n            this._enabled = false;\n            model.reset(true);\n            host.classList.remove(COMPLETER_ENABLED_CLASS);\n            return;\n        }\n        // Enable completion.\n        if (!this._enabled) {\n            this._enabled = true;\n            host.classList.add(COMPLETER_ENABLED_CLASS);\n        }\n        // Dispatch the cursor change.\n        model.handleCursorChange(this.getState(editor, editor.getCursorPosition()));\n    }\n    /**\n     * Handle a text changed signal from an editor.\n     */\n    onTextChanged() {\n        const model = this.completer.model;\n        if (!model || !this._enabled) {\n            return;\n        }\n        // If there is a text selection, no completion is allowed.\n        const editor = this.editor;\n        if (!editor) {\n            return;\n        }\n        const { start, end } = editor.getSelection();\n        if (start.column !== end.column || start.line !== end.line) {\n            return;\n        }\n        // Dispatch the text change.\n        model.handleTextChange(this.getState(editor, editor.getCursorPosition()));\n    }\n    /**\n     * Handle a visibility change signal from a completer widget.\n     */\n    onVisibilityChanged(completer) {\n        // Completer is not active.\n        if (completer.isDisposed || completer.isHidden) {\n            if (this._editor) {\n                this._editor.host.classList.remove(COMPLETER_ACTIVE_CLASS);\n                this._editor.focus();\n            }\n            return;\n        }\n        // Completer is active.\n        if (this._editor) {\n            this._editor.host.classList.add(COMPLETER_ACTIVE_CLASS);\n        }\n    }\n    /**\n     * Make a completion request.\n     */\n    _makeRequest(position) {\n        const editor = this.editor;\n        if (!editor) {\n            return Promise.reject(new Error('No active editor'));\n        }\n        const text = editor.model.value.text;\n        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);\n        const pending = ++this._pending;\n        const state = this.getState(editor, position);\n        const request = { text, offset };\n        if (this._isICompletionItemsConnector(this._connector)) {\n            return this._connector\n                .fetch(request)\n                .then(reply => {\n                this._validate(pending, request);\n                if (!reply) {\n                    throw new Error(`Invalid request: ${request}`);\n                }\n                this._onFetchItemsReply(state, reply);\n            })\n                .catch(_ => {\n                this._onFailure();\n            });\n        }\n        return this._connector\n            .fetch(request)\n            .then(reply => {\n            this._validate(pending, request);\n            if (!reply) {\n                throw new Error(`Invalid request: ${request}`);\n            }\n            this._onReply(state, reply);\n        })\n            .catch(_ => {\n            this._onFailure();\n        });\n    }\n    _isICompletionItemsConnector(connector) {\n        return (connector\n            .responseType === CompletionHandler.ICompletionItemsResponseType);\n    }\n    _validate(pending, request) {\n        if (this.isDisposed) {\n            throw new Error('Handler is disposed');\n        }\n        // If a newer completion request has created a pending request, bail.\n        if (pending !== this._pending) {\n            throw new Error('A newer completion request is pending');\n        }\n    }\n    /**\n     * Updates model with text state and current cursor position.\n     */\n    _updateModel(state, start, end) {\n        const model = this.completer.model;\n        const text = state.text;\n        if (!model) {\n            return null;\n        }\n        // Update the original request.\n        model.original = state;\n        // Update the cursor.\n        model.cursor = {\n            start: Text.charIndexToJsIndex(start, text),\n            end: Text.charIndexToJsIndex(end, text)\n        };\n        return model;\n    }\n    /**\n     * Receive a completion reply from the connector.\n     *\n     * @param state - The state of the editor when completion request was made.\n     *\n     * @param reply - The API response returned for a completion request.\n     */\n    _onReply(state, reply) {\n        const model = this._updateModel(state, reply.start, reply.end);\n        if (!model) {\n            return;\n        }\n        // Dedupe the matches.\n        const matches = [];\n        const matchSet = new Set(reply.matches || []);\n        if (reply.matches) {\n            matchSet.forEach(match => {\n                matches.push(match);\n            });\n        }\n        // Extract the optional type map. The current implementation uses\n        // _jupyter_types_experimental which provide string type names. We make no\n        // assumptions about the names of the types, so other kernels can provide\n        // their own types.\n        // Even though the `metadata` field is required, it has historically not\n        // been used. Defensively check if it exists.\n        const metadata = reply.metadata || {};\n        const types = metadata._jupyter_types_experimental;\n        const typeMap = {};\n        if (types) {\n            types.forEach((item) => {\n                // For some reason the _jupyter_types_experimental list has two entries\n                // for each match, with one having a type of \"<unknown>\". Discard those\n                // and use undefined to indicate an unknown type.\n                const text = item.text;\n                const type = item.type;\n                if (matchSet.has(text) && type !== '<unknown>') {\n                    typeMap[text] = type;\n                }\n            });\n        }\n        // Update the options, including the type map.\n        model.setOptions(matches, typeMap);\n    }\n    /**\n     * Receive completion items from provider.\n     *\n     * @param state - The state of the editor when completion request was made.\n     *\n     * @param reply - The API response returned for a completion request.\n     */\n    _onFetchItemsReply(state, reply) {\n        const model = this._updateModel(state, reply.start, reply.end);\n        if (!model) {\n            return;\n        }\n        if (model.setCompletionItems) {\n            model.setCompletionItems(reply.items);\n        }\n    }\n    /**\n     * If completion request fails, reset model and fail silently.\n     */\n    _onFailure() {\n        const model = this.completer.model;\n        if (model) {\n            model.reset(true);\n        }\n    }\n}\n/**\n * A namespace for cell completion handler statics.\n */\n(function (CompletionHandler) {\n    CompletionHandler.ICompletionItemsResponseType = 'ICompletionItemsReply';\n    /**\n     * A namespace for completion handler messages.\n     */\n    let Msg;\n    (function (Msg) {\n        /* tslint:disable */\n        /**\n         * A singleton `'invoke-request'` message.\n         */\n        Msg.InvokeRequest = new Message('invoke-request');\n        /* tslint:enable */\n    })(Msg = CompletionHandler.Msg || (CompletionHandler.Msg = {}));\n})(CompletionHandler || (CompletionHandler = {}));\n//# sourceMappingURL=handler.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * A kernel connector for completion handlers.\n */\nexport class KernelConnector extends DataConnector {\n    /**\n     * Create a new kernel connector for completion requests.\n     *\n     * @param options - The instantiation options for the kernel connector.\n     */\n    constructor(options) {\n        super();\n        this._session = options.session;\n    }\n    /**\n     * Fetch completion requests.\n     *\n     * @param request - The completion request text and details.\n     */\n    async fetch(request) {\n        var _a;\n        const kernel = (_a = this._session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            throw new Error('No kernel for completion request.');\n        }\n        const contents = {\n            code: request.text,\n            cursor_pos: request.offset\n        };\n        const msg = await kernel.requestComplete(contents);\n        const response = msg.content;\n        if (response.status !== 'ok') {\n            throw new Error('Completion fetch failed to return successfully.');\n        }\n        return {\n            start: response.cursor_start,\n            end: response.cursor_end,\n            matches: response.matches,\n            metadata: response.metadata\n        };\n    }\n}\n//# sourceMappingURL=kernelconnector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * A context connector for completion handlers.\n */\nexport class ContextConnector extends DataConnector {\n    /**\n     * Create a new context connector for completion requests.\n     *\n     * @param options - The instantiation options for the context connector.\n     */\n    constructor(options) {\n        super();\n        this._editor = options.editor;\n    }\n    /**\n     * Fetch completion requests.\n     *\n     * @param request - The completion request text and details.\n     */\n    fetch(request) {\n        if (!this._editor) {\n            return Promise.reject('No editor');\n        }\n        return new Promise(resolve => {\n            resolve(Private.contextHint(this._editor));\n        });\n    }\n}\n/**\n * A namespace for Private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Get a list of completion hints from a tokenization\n     * of the editor.\n     */\n    function contextHint(editor) {\n        // Find the token at the cursor\n        const cursor = editor.getCursorPosition();\n        const token = editor.getTokenForPosition(cursor);\n        // Get the list of matching tokens.\n        const tokenList = getCompletionTokens(token, editor);\n        // Only choose the ones that have a non-empty type\n        // field, which are likely to be of interest.\n        const completionList = tokenList.filter(t => t.type).map(t => t.value);\n        // Remove duplicate completions from the list\n        const matches = Array.from(new Set(completionList));\n        return {\n            start: token.offset,\n            end: token.offset + token.value.length,\n            matches,\n            metadata: {}\n        };\n    }\n    Private.contextHint = contextHint;\n    /**\n     * Get a list of tokens that match the completion request,\n     * but are not identical to the completion request.\n     */\n    function getCompletionTokens(token, editor) {\n        const candidates = editor.getTokens();\n        // Only get the tokens that have a common start, but\n        // are not identical.\n        return candidates.filter(t => t.value.indexOf(token.value) === 0 && t.value !== token.value);\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=contextconnector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\nimport { ContextConnector } from './contextconnector';\nimport { KernelConnector } from './kernelconnector';\n/**\n * A context+kernel connector for completion handlers.\n */\nexport class CompletionConnector extends DataConnector {\n    /**\n     * Create a new connector for completion requests.\n     *\n     * @param options - The instantiation options for the connector.\n     */\n    constructor(options) {\n        super();\n        this._kernel = new KernelConnector(options);\n        this._context = new ContextConnector(options);\n    }\n    /**\n     * Fetch completion requests.\n     *\n     * @param request - The completion request text and details.\n     */\n    fetch(request) {\n        return Promise.all([\n            this._kernel.fetch(request),\n            this._context.fetch(request)\n        ]).then(([kernel, context]) => Private.mergeReplies(kernel, context));\n    }\n}\n/**\n * A namespace for private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Merge results from kernel and context completions.\n     *\n     * @param kernel - The kernel reply being merged.\n     *\n     * @param context - The context reply being merged.\n     *\n     * @returns A reply with a superset of kernel and context matches.\n     *\n     * #### Notes\n     * The kernel and context matches are merged with a preference for kernel\n     * results. Both lists are known to contain unique, non-repeating items;\n     * so this function returns a non-repeating superset by filtering out\n     * duplicates from the context list that appear in the kernel list.\n     */\n    function mergeReplies(kernel, context) {\n        // If one is empty, return the other.\n        if (kernel.matches.length === 0) {\n            return context;\n        }\n        else if (context.matches.length === 0) {\n            return kernel;\n        }\n        // Populate the result with a copy of the kernel matches.\n        const matches = kernel.matches.slice();\n        // Cache all the kernel matches in a memo.\n        const memo = matches.reduce((acc, val) => {\n            acc[val] = null;\n            return acc;\n        }, {});\n        // Add each context match that is not in the memo to the result.\n        context.matches.forEach(match => {\n            if (!(match in memo)) {\n                matches.push(match);\n            }\n        });\n        return Object.assign(Object.assign({}, kernel), { matches });\n    }\n    Private.mergeReplies = mergeReplies;\n})(Private || (Private = {}));\n//# sourceMappingURL=connector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { iter, map, StringExt, toArray } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\n/**\n * An implementation of a completer model.\n */\nexport class CompleterModel {\n    constructor() {\n        this._current = null;\n        this._cursor = null;\n        this._isDisposed = false;\n        this._completionItems = [];\n        this._options = [];\n        this._original = null;\n        this._query = '';\n        this._subsetMatch = false;\n        this._typeMap = {};\n        this._orderedTypes = [];\n        this._stateChanged = new Signal(this);\n    }\n    /**\n     * A signal emitted when state of the completer menu changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * The original completion request details.\n     */\n    get original() {\n        return this._original;\n    }\n    set original(newValue) {\n        const unchanged = this._original === newValue ||\n            (this._original &&\n                newValue &&\n                JSONExt.deepEqual(newValue, this._original));\n        if (unchanged) {\n            return;\n        }\n        this._reset();\n        // Set both the current and original to the same value when original is set.\n        this._current = this._original = newValue;\n        this._stateChanged.emit(undefined);\n    }\n    /**\n     * The current text change details.\n     */\n    get current() {\n        return this._current;\n    }\n    set current(newValue) {\n        const unchanged = this._current === newValue ||\n            (this._current && newValue && JSONExt.deepEqual(newValue, this._current));\n        if (unchanged) {\n            return;\n        }\n        const original = this._original;\n        // Original request must always be set before a text change. If it isn't\n        // the model fails silently.\n        if (!original) {\n            return;\n        }\n        const cursor = this._cursor;\n        // Cursor must always be set before a text change. This happens\n        // automatically in the completer handler, but since `current` is a public\n        // attribute, this defensive check is necessary.\n        if (!cursor) {\n            return;\n        }\n        const current = (this._current = newValue);\n        if (!current) {\n            this._stateChanged.emit(undefined);\n            return;\n        }\n        const originalLine = original.text.split('\\n')[original.line];\n        const currentLine = current.text.split('\\n')[current.line];\n        // If the text change means that the original start point has been preceded,\n        // then the completion is no longer valid and should be reset.\n        if (!this._subsetMatch && currentLine.length < originalLine.length) {\n            this.reset(true);\n            return;\n        }\n        const { start, end } = cursor;\n        // Clip the front of the current line.\n        let query = current.text.substring(start);\n        // Clip the back of the current line by calculating the end of the original.\n        const ending = original.text.substring(end);\n        query = query.substring(0, query.lastIndexOf(ending));\n        this._query = query;\n        this._stateChanged.emit(undefined);\n    }\n    /**\n     * The cursor details that the API has used to return matching options.\n     */\n    get cursor() {\n        return this._cursor;\n    }\n    set cursor(newValue) {\n        // Original request must always be set before a cursor change. If it isn't\n        // the model fails silently.\n        if (!this.original) {\n            return;\n        }\n        this._cursor = newValue;\n    }\n    /**\n     * The query against which items are filtered.\n     */\n    get query() {\n        return this._query;\n    }\n    set query(newValue) {\n        this._query = newValue;\n    }\n    /**\n     * A flag that is true when the model value was modified by a subset match.\n     */\n    get subsetMatch() {\n        return this._subsetMatch;\n    }\n    set subsetMatch(newValue) {\n        this._subsetMatch = newValue;\n    }\n    /**\n     * Get whether the model is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * The list of visible items in the completer menu.\n     *\n     * #### Notes\n     * This is a read-only property.\n     */\n    completionItems() {\n        let query = this._query;\n        if (query) {\n            return this._markup(query);\n        }\n        return this._completionItems;\n    }\n    /**\n     * Set the list of visible items in the completer menu, and append any\n     * new types to KNOWN_TYPES.\n     */\n    setCompletionItems(newValue) {\n        if (JSONExt.deepEqual(newValue, this._completionItems)) {\n            return;\n        }\n        this._completionItems = newValue;\n        this._orderedTypes = Private.findOrderedCompletionItemTypes(this._completionItems);\n        this._stateChanged.emit(undefined);\n    }\n    /**\n     * The list of visible items in the completer menu.\n     * @deprecated use `completionItems` instead\n     *\n     * #### Notes\n     * This is a read-only property.\n     */\n    items() {\n        return this._filter();\n    }\n    /**\n     * The unfiltered list of all available options in a completer menu.\n     */\n    options() {\n        return iter(this._options);\n    }\n    /**\n     * The map from identifiers (a.b) to types (function, module, class, instance,\n     * etc.).\n     *\n     * #### Notes\n     * A type map is currently only provided by the latest IPython kernel using\n     * the completer reply metadata field `_jupyter_types_experimental`. The\n     * values are completely up to the kernel.\n     *\n     */\n    typeMap() {\n        return this._typeMap;\n    }\n    /**\n     * An ordered list of all the known types in the typeMap.\n     *\n     * #### Notes\n     * To visually encode the types of the completer matches, we assemble an\n     * ordered list. This list begins with:\n     * ```\n     * ['function', 'instance', 'class', 'module', 'keyword']\n     * ```\n     * and then has any remaining types listed alphabetically. This will give\n     * reliable visual encoding for these known types, but allow kernels to\n     * provide new types.\n     */\n    orderedTypes() {\n        return this._orderedTypes;\n    }\n    /**\n     * Set the available options in the completer menu.\n     */\n    setOptions(newValue, typeMap) {\n        const values = toArray(newValue || []);\n        const types = typeMap || {};\n        if (JSONExt.deepEqual(values, this._options) &&\n            JSONExt.deepEqual(types, this._typeMap)) {\n            return;\n        }\n        if (values.length) {\n            this._options = values;\n            this._typeMap = types;\n            this._orderedTypes = Private.findOrderedTypes(types);\n        }\n        else {\n            this._options = [];\n            this._typeMap = {};\n            this._orderedTypes = [];\n        }\n        this._stateChanged.emit(undefined);\n    }\n    /**\n     * Handle a cursor change.\n     */\n    handleCursorChange(change) {\n        // If there is no active completion, return.\n        if (!this._original) {\n            return;\n        }\n        const { column, line } = change;\n        const { current, original } = this;\n        if (!original) {\n            return;\n        }\n        // If a cursor change results in a the cursor being on a different line\n        // than the original request, cancel.\n        if (line !== original.line) {\n            this.reset(true);\n            return;\n        }\n        // If a cursor change results in the cursor being set to a position that\n        // precedes the original column, cancel.\n        if (column < original.column) {\n            this.reset(true);\n            return;\n        }\n        const { cursor } = this;\n        if (!cursor || !current) {\n            return;\n        }\n        // If a cursor change results in the cursor being set to a position beyond\n        // the end of the area that would be affected by completion, cancel.\n        const cursorDelta = cursor.end - cursor.start;\n        const originalLine = original.text.split('\\n')[original.line];\n        const currentLine = current.text.split('\\n')[current.line];\n        const inputDelta = currentLine.length - originalLine.length;\n        if (column > original.column + cursorDelta + inputDelta) {\n            this.reset(true);\n            return;\n        }\n    }\n    /**\n     * Handle a text change.\n     */\n    handleTextChange(change) {\n        const original = this._original;\n        // If there is no active completion, return.\n        if (!original) {\n            return;\n        }\n        const { text, column, line } = change;\n        const last = text.split('\\n')[line][column - 1];\n        // If last character entered is not whitespace or if the change column is\n        // greater than or equal to the original column, update completion.\n        if ((last && last.match(/\\S/)) || change.column >= original.column) {\n            this.current = change;\n            return;\n        }\n        // If final character is whitespace, reset completion.\n        this.reset(false);\n    }\n    /**\n     * Create a resolved patch between the original state and a patch string.\n     *\n     * @param patch - The patch string to apply to the original value.\n     *\n     * @returns A patched text change or undefined if original value did not exist.\n     */\n    createPatch(patch) {\n        const original = this._original;\n        const cursor = this._cursor;\n        const current = this._current;\n        if (!original || !cursor || !current) {\n            return undefined;\n        }\n        let { start, end } = cursor;\n        // Also include any filtering/additional-typing that has occurred\n        // since the completion request in the patched length.\n        end = end + (current.text.length - original.text.length);\n        return { start, end, value: patch };\n    }\n    /**\n     * Reset the state of the model and emit a state change signal.\n     *\n     * @param hard - Reset even if a subset match is in progress.\n     */\n    reset(hard = false) {\n        // When the completer detects a common subset prefix for all options,\n        // it updates the model and sets the model source to that value, triggering\n        // a reset. Unless explicitly a hard reset, this should be ignored.\n        if (!hard && this._subsetMatch) {\n            return;\n        }\n        this._reset();\n        this._stateChanged.emit(undefined);\n    }\n    /**\n     * Check if CompletionItem matches against query.\n     * Highlight matching prefix by adding <mark> tags.\n     */\n    _markup(query) {\n        const items = this._completionItems;\n        let results = [];\n        for (let item of items) {\n            // See if label matches query string\n            // With ICompletionItems, the label may include parameters, so we exclude them from the matcher.\n            // e.g. Given label `foo(b, a, r)` and query `bar`,\n            // don't count parameters, `b`, `a`, and `r` as matches.\n            const index = item.label.indexOf('(');\n            const prefix = index > -1 ? item.label.substring(0, index) : item.label;\n            let match = StringExt.matchSumOfSquares(prefix, query);\n            // Filter non-matching items.\n            if (match) {\n                // Highlight label text if there's a match\n                let marked = StringExt.highlight(item.label, match.indices, Private.mark);\n                results.push(Object.assign(Object.assign({}, item), { \n                    // Allow for lazily retrieved documentation (with a getter)\n                    documentation: item.documentation, label: marked.join(''), \n                    // If no insertText is present, preserve original label value\n                    // by setting it as the insertText.\n                    insertText: item.insertText ? item.insertText : item.label, score: match.score }));\n            }\n        }\n        results.sort(Private.scoreCmp2);\n        // Delete the extra score attribute to not leak implementation details\n        // to JavaScript callers.\n        results.forEach(x => {\n            delete x.score;\n        });\n        return results;\n    }\n    /**\n     * Apply the query to the complete options list to return the matching subset.\n     */\n    _filter() {\n        const options = this._options || [];\n        const query = this._query;\n        if (!query) {\n            return map(options, option => ({ raw: option, text: option }));\n        }\n        const results = [];\n        for (const option of options) {\n            const match = StringExt.matchSumOfSquares(option, query);\n            if (match) {\n                const marked = StringExt.highlight(option, match.indices, Private.mark);\n                results.push({\n                    raw: option,\n                    score: match.score,\n                    text: marked.join('')\n                });\n            }\n        }\n        return map(results.sort(Private.scoreCmp), result => ({\n            text: result.text,\n            raw: result.raw\n        }));\n    }\n    /**\n     * Reset the state of the model.\n     */\n    _reset() {\n        this._current = null;\n        this._cursor = null;\n        this._completionItems = [];\n        this._options = [];\n        this._original = null;\n        this._query = '';\n        this._subsetMatch = false;\n        this._typeMap = {};\n        this._orderedTypes = [];\n    }\n}\n/**\n * A namespace for completer model private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The list of known type annotations of completer matches.\n     */\n    const KNOWN_TYPES = ['function', 'instance', 'class', 'module', 'keyword'];\n    /**\n     * The map of known type annotations of completer matches.\n     */\n    const KNOWN_MAP = KNOWN_TYPES.reduce((acc, type) => {\n        acc[type] = null;\n        return acc;\n    }, {});\n    /**\n     * Mark a highlighted chunk of text.\n     */\n    function mark(value) {\n        return `<mark>${value}</mark>`;\n    }\n    Private.mark = mark;\n    /**\n     * A sort comparison function for item match scores.\n     *\n     * #### Notes\n     * This orders the items first based on score (lower is better), then\n     * by locale order of the item text.\n     */\n    function scoreCmp(a, b) {\n        const delta = a.score - b.score;\n        if (delta !== 0) {\n            return delta;\n        }\n        return a.raw.localeCompare(b.raw);\n    }\n    Private.scoreCmp = scoreCmp;\n    /**\n     * A sort comparison function for item match scores.\n     *\n     * #### Notes\n     * This orders the items first based on score (lower is better), then\n     * by locale order of the item text.\n     */\n    function scoreCmp2(a, b) {\n        var _a, _b, _c;\n        const delta = a.score - b.score;\n        if (delta !== 0) {\n            return delta;\n        }\n        return (_c = (_a = a.insertText) === null || _a === void 0 ? void 0 : _a.localeCompare((_b = b.insertText) !== null && _b !== void 0 ? _b : '')) !== null && _c !== void 0 ? _c : 0;\n    }\n    Private.scoreCmp2 = scoreCmp2;\n    /**\n     * Compute a reliably ordered list of types for ICompletionItems.\n     *\n     * #### Notes\n     * The resulting list always begins with the known types:\n     * ```\n     * ['function', 'instance', 'class', 'module', 'keyword']\n     * ```\n     * followed by other types in alphabetical order.\n     *\n     */\n    function findOrderedCompletionItemTypes(items) {\n        const newTypeSet = new Set();\n        items.forEach(item => {\n            if (item.type &&\n                !KNOWN_TYPES.includes(item.type) &&\n                !newTypeSet.has(item.type)) {\n                newTypeSet.add(item.type);\n            }\n        });\n        const newTypes = Array.from(newTypeSet);\n        newTypes.sort((a, b) => a.localeCompare(b));\n        return KNOWN_TYPES.concat(newTypes);\n    }\n    Private.findOrderedCompletionItemTypes = findOrderedCompletionItemTypes;\n    /**\n     * Compute a reliably ordered list of types.\n     *\n     * #### Notes\n     * The resulting list always begins with the known types:\n     * ```\n     * ['function', 'instance', 'class', 'module', 'keyword']\n     * ```\n     * followed by other types in alphabetical order.\n     */\n    function findOrderedTypes(typeMap) {\n        const filtered = Object.keys(typeMap)\n            .map(key => typeMap[key])\n            .filter((value) => !!value && !(value in KNOWN_MAP))\n            .sort((a, b) => a.localeCompare(b));\n        return KNOWN_TYPES.concat(filtered);\n    }\n    Private.findOrderedTypes = findOrderedTypes;\n})(Private || (Private = {}));\n//# sourceMappingURL=model.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { defaultSanitizer, HoverBox } from '@jupyterlab/apputils';\nimport { toArray } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { ElementExt } from '@lumino/domutils';\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\n/**\n * The class name added to completer menu items.\n */\nconst ITEM_CLASS = 'jp-Completer-item';\n/**\n * The class name added to an active completer menu item.\n */\nconst ACTIVE_CLASS = 'jp-mod-active';\n/**\n * The minimum height of a completer widget.\n */\nconst MIN_HEIGHT = 20;\n/**\n * The maximum height of a completer widget.\n */\nconst MAX_HEIGHT = 300;\n/**\n * A flag to indicate that event handlers are caught in the capture phase.\n */\nconst USE_CAPTURE = true;\n/**\n * The number of colors defined for the completer type annotations.\n * These are listed in completer/style/index.css#102-152.\n */\nconst N_COLORS = 10;\n/**\n * A widget that enables text completion.\n *\n * #### Notes\n * The completer is intended to be absolutely positioned on the\n * page and hover over any other content, so it should be attached directly\n * to `document.body`, or a node that is the full size of `document.body`.\n * Attaching it to other nodes may incorrectly locate the completer.\n */\nexport class Completer extends Widget {\n    /**\n     * Construct a text completer menu widget.\n     */\n    constructor(options) {\n        super({ node: document.createElement('div') });\n        this._activeIndex = 0;\n        this._editor = null;\n        this._model = null;\n        this._resetFlag = false;\n        this._selected = new Signal(this);\n        this._visibilityChanged = new Signal(this);\n        this._indexChanged = new Signal(this);\n        this._lastSubsetMatch = '';\n        this._renderer = options.renderer || Completer.defaultRenderer;\n        this.model = options.model || null;\n        this.editor = options.editor || null;\n        this.addClass('jp-Completer');\n    }\n    /**\n     * The active index.\n     */\n    get activeIndex() {\n        return this._activeIndex;\n    }\n    /**\n     * The editor used by the completion widget.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        this._editor = newValue;\n    }\n    /**\n     * A signal emitted when a selection is made from the completer menu.\n     */\n    get selected() {\n        return this._selected;\n    }\n    /**\n     * A signal emitted when the completer widget's visibility changes.\n     *\n     * #### Notes\n     * This signal is useful when there are multiple floating widgets that may\n     * contend with the same space and ought to be mutually exclusive.\n     */\n    get visibilityChanged() {\n        return this._visibilityChanged;\n    }\n    /**\n     * A signal emitted when the active index changes.\n     */\n    get indexChanged() {\n        return this._indexChanged;\n    }\n    /**\n     * The model used by the completer widget.\n     */\n    get model() {\n        return this._model;\n    }\n    set model(model) {\n        if ((!model && !this._model) || model === this._model) {\n            return;\n        }\n        if (this._model) {\n            this._model.stateChanged.disconnect(this.onModelStateChanged, this);\n        }\n        this._model = model;\n        if (this._model) {\n            this._model.stateChanged.connect(this.onModelStateChanged, this);\n        }\n    }\n    /**\n     * Dispose of the resources held by the completer widget.\n     */\n    dispose() {\n        this._model = null;\n        super.dispose();\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the dock panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        switch (event.type) {\n            case 'keydown':\n                this._evtKeydown(event);\n                break;\n            case 'mousedown':\n                this._evtMousedown(event);\n                break;\n            case 'scroll':\n                this._evtScroll(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Reset the widget.\n     */\n    reset() {\n        this._activeIndex = 0;\n        this._lastSubsetMatch = '';\n        if (this._model) {\n            this._model.reset(true);\n        }\n    }\n    /**\n     * Emit the selected signal for the current active item and reset.\n     */\n    selectActive() {\n        const active = this.node.querySelector(`.${ACTIVE_CLASS}`);\n        if (!active) {\n            this.reset();\n            return;\n        }\n        this._selected.emit(active.getAttribute('data-value'));\n        this.reset();\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        document.addEventListener('keydown', this, USE_CAPTURE);\n        document.addEventListener('mousedown', this, USE_CAPTURE);\n        document.addEventListener('scroll', this, USE_CAPTURE);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        document.removeEventListener('keydown', this, USE_CAPTURE);\n        document.removeEventListener('mousedown', this, USE_CAPTURE);\n        document.removeEventListener('scroll', this, USE_CAPTURE);\n    }\n    /**\n     * Handle model state changes.\n     */\n    onModelStateChanged() {\n        if (this.isAttached) {\n            this._activeIndex = 0;\n            this._indexChanged.emit(this._activeIndex);\n            this.update();\n        }\n    }\n    /**\n     * Handle `update-request` messages.\n     */\n    onUpdateRequest(msg) {\n        const model = this._model;\n        if (!model) {\n            return;\n        }\n        if (this._resetFlag) {\n            this._resetFlag = false;\n            if (!this.isHidden) {\n                this.hide();\n                this._visibilityChanged.emit(undefined);\n            }\n            return;\n        }\n        let node = null;\n        let completionItemList = model.completionItems && model.completionItems();\n        if (completionItemList && completionItemList.length) {\n            node = this._createCompletionItemNode(model, completionItemList);\n        }\n        else {\n            node = this._createIItemNode(model);\n        }\n        if (!node) {\n            return;\n        }\n        let active = node.querySelectorAll(`.${ITEM_CLASS}`)[this._activeIndex];\n        active.classList.add(ACTIVE_CLASS);\n        // Add the documentation panel\n        let docPanel = document.createElement('div');\n        docPanel.className = 'jp-Completer-docpanel';\n        node.appendChild(docPanel);\n        this._updateDocPanel();\n        // If this is the first time the current completer session has loaded,\n        // populate any initial subset match.\n        if (!model.query) {\n            const populated = this._populateSubset();\n            if (populated) {\n                this.update();\n                return;\n            }\n        }\n        if (this.isHidden) {\n            this.show();\n            this._setGeometry();\n            this._visibilityChanged.emit(undefined);\n        }\n        else {\n            this._setGeometry();\n        }\n    }\n    _createCompletionItemNode(model, items) {\n        // If there are no items, reset and bail.\n        if (!items.length) {\n            this._resetFlag = true;\n            this.reset();\n            if (!this.isHidden) {\n                this.hide();\n                this._visibilityChanged.emit(undefined);\n            }\n            return null;\n        }\n        // Clear the node.\n        let node = this.node;\n        node.textContent = '';\n        // Compute an ordered list of all the types in the typeMap, this is computed\n        // once by the model each time new data arrives for efficiency.\n        let orderedTypes = model.orderedTypes();\n        // Populate the completer items.\n        let ul = document.createElement('ul');\n        ul.className = 'jp-Completer-list';\n        for (let item of items) {\n            if (!this._renderer.createCompletionItemNode) {\n                return null;\n            }\n            let li = this._renderer.createCompletionItemNode(item, orderedTypes);\n            ul.appendChild(li);\n        }\n        node.appendChild(ul);\n        return node;\n    }\n    _createIItemNode(model) {\n        const items = toArray(model.items());\n        // If there are no items, reset and bail.\n        if (!items || !items.length) {\n            this._resetFlag = true;\n            this.reset();\n            if (!this.isHidden) {\n                this.hide();\n                this._visibilityChanged.emit(undefined);\n            }\n            return null;\n        }\n        // If there is only one option, signal and bail.\n        // We don't test the filtered `items`, as that\n        // is too aggressive of completer behavior, it can\n        // lead to double typing of an option.\n        const options = toArray(model.options());\n        if (options.length === 1) {\n            this._selected.emit(options[0]);\n            this.reset();\n            return null;\n        }\n        // Clear the node.\n        const node = this.node;\n        node.textContent = '';\n        // Compute an ordered list of all the types in the typeMap, this is computed\n        // once by the model each time new data arrives for efficiency.\n        const orderedTypes = model.orderedTypes();\n        // Populate the completer items.\n        let ul = document.createElement('ul');\n        ul.className = 'jp-Completer-list';\n        for (const item of items) {\n            const li = this._renderer.createItemNode(item, model.typeMap(), orderedTypes);\n            ul.appendChild(li);\n        }\n        node.appendChild(ul);\n        return node;\n    }\n    /**\n     * Cycle through the available completer items.\n     *\n     * #### Notes\n     * When the user cycles all the way `down` to the last index, subsequent\n     * `down` cycles will cycle to the first index. When the user cycles `up` to\n     * the first item, subsequent `up` cycles will cycle to the last index.\n     */\n    _cycle(direction) {\n        const items = this.node.querySelectorAll(`.${ITEM_CLASS}`);\n        const index = this._activeIndex;\n        let active = this.node.querySelector(`.${ACTIVE_CLASS}`);\n        active.classList.remove(ACTIVE_CLASS);\n        if (direction === 'up') {\n            this._activeIndex = index === 0 ? items.length - 1 : index - 1;\n        }\n        else if (direction === 'down') {\n            this._activeIndex = index < items.length - 1 ? index + 1 : 0;\n        }\n        else {\n            // Measure the number of items on a page.\n            const boxHeight = this.node.getBoundingClientRect().height;\n            const itemHeight = active.getBoundingClientRect().height;\n            const pageLength = Math.floor(boxHeight / itemHeight);\n            // Update the index\n            if (direction === 'pageUp') {\n                this._activeIndex = index - pageLength;\n            }\n            else {\n                this._activeIndex = index + pageLength;\n            }\n            // Clamp to the length of the list.\n            this._activeIndex = Math.min(Math.max(0, this._activeIndex), items.length - 1);\n        }\n        active = items[this._activeIndex];\n        active.classList.add(ACTIVE_CLASS);\n        let completionList = this.node.querySelector('.jp-Completer-list');\n        ElementExt.scrollIntoViewIfNeeded(completionList, active);\n        this._indexChanged.emit(this._activeIndex);\n        this._updateDocPanel();\n    }\n    /**\n     * Handle keydown events for the widget.\n     */\n    _evtKeydown(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        if (!this._editor.host.contains(event.target)) {\n            this.reset();\n            return;\n        }\n        switch (event.keyCode) {\n            case 9: {\n                // Tab key\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                const model = this._model;\n                if (!model) {\n                    return;\n                }\n                // Autoinsert single completions on manual request (tab)\n                const items = model.completionItems && model.completionItems();\n                if (items && items.length === 1) {\n                    this._selected.emit(items[0].insertText || items[0].label);\n                    this.reset();\n                    return;\n                }\n                const populated = this._populateSubset();\n                // If the common subset was found and set on `query`,\n                // or if there is a `query` in the initialization options,\n                // then emit a completion signal with that `query` (=subset match),\n                // but only if the query has actually changed.\n                // See: https://github.com/jupyterlab/jupyterlab/issues/10439#issuecomment-875189540\n                if (model.query && model.query != this._lastSubsetMatch) {\n                    model.subsetMatch = true;\n                    this._selected.emit(model.query);\n                    model.subsetMatch = false;\n                    this._lastSubsetMatch = model.query;\n                }\n                // If the query changed, update rendering of the options.\n                if (populated) {\n                    this.update();\n                }\n                this._cycle(event.shiftKey ? 'up' : 'down');\n                return;\n            }\n            case 27: // Esc key\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                this.reset();\n                return;\n            case 33: // PageUp\n            case 34: // PageDown\n            case 38: // Up arrow key\n            case 40: {\n                // Down arrow key\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                const cycle = Private.keyCodeMap[event.keyCode];\n                this._cycle(cycle);\n                return;\n            }\n            default:\n                return;\n        }\n    }\n    /**\n     * Handle mousedown events for the widget.\n     */\n    _evtMousedown(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        if (Private.nonstandardClick(event)) {\n            this.reset();\n            return;\n        }\n        let target = event.target;\n        while (target !== document.documentElement) {\n            // If the user has made a selection, emit its value and reset the widget.\n            if (target.classList.contains(ITEM_CLASS)) {\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                this._selected.emit(target.getAttribute('data-value'));\n                this.reset();\n                return;\n            }\n            // If the mouse event happened anywhere else in the widget, bail.\n            if (target === this.node) {\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                return;\n            }\n            target = target.parentElement;\n        }\n        this.reset();\n    }\n    /**\n     * Handle scroll events for the widget\n     */\n    _evtScroll(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        const { node } = this;\n        // All scrolls except scrolls in the actual hover box node may cause the\n        // referent editor that anchors the node to move, so the only scroll events\n        // that can safely be ignored are ones that happen inside the hovering node.\n        if (node.contains(event.target)) {\n            return;\n        }\n        // Set the geometry of the node asynchronously.\n        requestAnimationFrame(() => {\n            this._setGeometry();\n        });\n    }\n    /**\n     * Populate the completer up to the longest initial subset of items.\n     *\n     * @returns `true` if a subset match was found and populated.\n     */\n    _populateSubset() {\n        const { model } = this;\n        if (!model) {\n            return false;\n        }\n        const items = this.node.querySelectorAll(`.${ITEM_CLASS}`);\n        const subset = Private.commonSubset(Private.itemValues(items));\n        const { query } = model;\n        // If a common subset exists and it is not the current query, highlight it.\n        if (subset && subset !== query && subset.indexOf(query) === 0) {\n            model.query = subset;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Set the visible dimensions of the widget.\n     */\n    _setGeometry() {\n        const { node } = this;\n        const model = this._model;\n        const editor = this._editor;\n        // This is an overly defensive test: `cursor` will always exist if\n        // `original` exists, except in contrived tests. But since it is possible\n        // to generate a runtime error, the check occurs here.\n        if (!editor || !model || !model.original || !model.cursor) {\n            return;\n        }\n        const start = model.cursor.start;\n        const position = editor.getPositionAt(start);\n        const anchor = editor.getCoordinateForPosition(position);\n        const style = window.getComputedStyle(node);\n        const borderLeft = parseInt(style.borderLeftWidth, 10) || 0;\n        const paddingLeft = parseInt(style.paddingLeft, 10) || 0;\n        // Calculate the geometry of the completer.\n        HoverBox.setGeometry({\n            anchor,\n            host: editor.host,\n            maxHeight: MAX_HEIGHT,\n            minHeight: MIN_HEIGHT,\n            node: node,\n            offset: { horizontal: borderLeft + paddingLeft },\n            privilege: 'below',\n            style: style\n        });\n    }\n    /**\n     * Update the display-state and contents of the documentation panel\n     */\n    _updateDocPanel() {\n        var _a, _b;\n        let docPanel = this.node.querySelector('.jp-Completer-docpanel');\n        if (!docPanel) {\n            return;\n        }\n        if (!((_a = this.model) === null || _a === void 0 ? void 0 : _a.completionItems)) {\n            return;\n        }\n        let items = (_b = this.model) === null || _b === void 0 ? void 0 : _b.completionItems();\n        if (!items) {\n            docPanel.setAttribute('style', 'display:none');\n            return;\n        }\n        let activeItem = items[this._activeIndex];\n        if (!activeItem) {\n            docPanel.setAttribute('style', 'display:none');\n            return;\n        }\n        docPanel.textContent = '';\n        if (activeItem.documentation) {\n            let node;\n            if (!this._renderer.createDocumentationNode) {\n                node = Completer.defaultRenderer.createDocumentationNode(activeItem);\n            }\n            else {\n                node = this._renderer.createDocumentationNode(activeItem);\n            }\n            docPanel.appendChild(node);\n            docPanel.setAttribute('style', '');\n        }\n        else {\n            docPanel.setAttribute('style', 'display:none');\n        }\n    }\n}\n(function (Completer) {\n    /**\n     * The default implementation of an `IRenderer`.\n     */\n    class Renderer {\n        /**\n         * Create an item node from an ICompletionItem for a text completer menu.\n         */\n        createCompletionItemNode(item, orderedTypes) {\n            let baseNode = this._createBaseNode(item.insertText || item.label);\n            if (item.deprecated) {\n                baseNode.classList.add('jp-Completer-deprecated');\n            }\n            return this._constructNode(baseNode, this._createMatchNode(item.label), !!item.type, item.type, orderedTypes, item.icon);\n        }\n        /**\n         * Create an item node for a text completer menu.\n         */\n        createItemNode(item, typeMap, orderedTypes) {\n            return this._constructNode(this._createBaseNode(item.raw), this._createMatchNode(item.text), !JSONExt.deepEqual(typeMap, {}), typeMap[item.raw] || '', orderedTypes);\n        }\n        /**\n         * Create a documentation node for documentation panel.\n         */\n        createDocumentationNode(activeItem) {\n            let pre = document.createElement('pre');\n            pre.textContent = activeItem.documentation || '';\n            return pre;\n        }\n        /**\n         * Create base node with the value to be inserted\n         */\n        _createBaseNode(value) {\n            const li = document.createElement('li');\n            li.className = ITEM_CLASS;\n            // Set the raw, un-marked up value as a data attribute.\n            li.setAttribute('data-value', value);\n            return li;\n        }\n        /**\n         * Create match node to highlight potential prefix match within result.\n         */\n        _createMatchNode(result) {\n            const matchNode = document.createElement('code');\n            matchNode.className = 'jp-Completer-match';\n            // Use innerHTML because search results include <mark> tags.\n            matchNode.innerHTML = defaultSanitizer.sanitize(result, {\n                allowedTags: ['mark']\n            });\n            return matchNode;\n        }\n        /**\n         * Attaches type and match nodes to base node.\n         */\n        _constructNode(li, matchNode, typesExist, type, orderedTypes, icon) {\n            // Add the icon or type monogram\n            if (icon) {\n                const iconNode = icon.element({\n                    className: 'jp-Completer-type jp-Completer-icon'\n                });\n                li.appendChild(iconNode);\n            }\n            else if (typesExist) {\n                const typeNode = document.createElement('span');\n                typeNode.textContent = (type[0] || '').toLowerCase();\n                const colorIndex = (orderedTypes.indexOf(type) % N_COLORS) + 1;\n                typeNode.className = 'jp-Completer-type jp-Completer-monogram';\n                typeNode.setAttribute(`data-color-index`, colorIndex.toString());\n                li.appendChild(typeNode);\n            }\n            else {\n                // Create empty span to ensure consistent list styling.\n                // Otherwise, in a list of two items,\n                // if one item has an icon, but the other has type,\n                // the icon grows out of its bounds.\n                const dummyNode = document.createElement('span');\n                dummyNode.className = 'jp-Completer-monogram';\n                li.appendChild(dummyNode);\n            }\n            li.appendChild(matchNode);\n            // If there is a type, add the type extension and title\n            if (typesExist) {\n                li.title = type;\n                const typeExtendedNode = document.createElement('code');\n                typeExtendedNode.className = 'jp-Completer-typeExtended';\n                typeExtendedNode.textContent = type.toLocaleLowerCase();\n                li.appendChild(typeExtendedNode);\n            }\n            else {\n                // If no type is present on the right,\n                // the highlighting of the completion item\n                // doesn't cover the entire row.\n                const dummyTypeExtendedNode = document.createElement('span');\n                dummyTypeExtendedNode.className = 'jp-Completer-typeExtended';\n                li.appendChild(dummyTypeExtendedNode);\n            }\n            return li;\n        }\n    }\n    Completer.Renderer = Renderer;\n    /**\n     * The default `IRenderer` instance.\n     */\n    Completer.defaultRenderer = new Renderer();\n})(Completer || (Completer = {}));\n/**\n * A namespace for completer widget private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Mapping from keyCodes to scrollTypes.\n     */\n    Private.keyCodeMap = {\n        38: 'up',\n        40: 'down',\n        33: 'pageUp',\n        34: 'pageDown'\n    };\n    /**\n     * Returns the common subset string that a list of strings shares.\n     */\n    function commonSubset(values) {\n        const len = values.length;\n        let subset = '';\n        if (len < 2) {\n            return subset;\n        }\n        const strlen = values[0].length;\n        for (let i = 0; i < strlen; i++) {\n            const ch = values[0][i];\n            for (let j = 1; j < len; j++) {\n                if (values[j][i] !== ch) {\n                    return subset;\n                }\n            }\n            subset += ch;\n        }\n        return subset;\n    }\n    Private.commonSubset = commonSubset;\n    /**\n     * Returns the list of raw item values currently in the DOM.\n     */\n    function itemValues(items) {\n        const values = [];\n        for (let i = 0, len = items.length; i < len; i++) {\n            const attr = items[i].getAttribute('data-value');\n            if (attr) {\n                values.push(attr);\n            }\n        }\n        return values;\n    }\n    Private.itemValues = itemValues;\n    /**\n     * Returns true for any modified click event (i.e., not a left-click).\n     */\n    function nonstandardClick(event) {\n        return (event.button !== 0 ||\n            event.altKey ||\n            event.ctrlKey ||\n            event.shiftKey ||\n            event.metaKey);\n    }\n    Private.nonstandardClick = nonstandardClick;\n})(Private || (Private = {}));\n//# sourceMappingURL=widget.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The completion manager token.\n */\nexport const ICompletionManager = new Token('@jupyterlab/completer:ICompletionManager');\n//# sourceMappingURL=tokens.js.map"],"names":["DummyConnector","DataConnector","fetch","_","Promise","reject","COMPLETER_ENABLED_CLASS","COMPLETER_ACTIVE_CLASS","CompletionHandler","constructor","options","this","_editor","_enabled","_pending","_isDisposed","completer","selected","connect","onCompletionSelected","visibilityChanged","onVisibilityChanged","_connector","connector","editor","newValue","isDisposed","model","host","classList","remove","selections","changed","disconnect","onSelectionsChanged","value","onTextChanged","reset","dispose","Signal","invoke","MessageLoop","Msg","InvokeRequest","processMessage","msg","type","onInvokeRequest","getState","position","text","lineHeight","charWidth","line","column","val","patch","createPatch","start","end","cursorBeforeChange","getOffsetAt","getCursorPosition","sharedModel","updateSource","setCursorPosition","getPositionAt","length","original","_makeRequest","catch","reason","console","warn","subsetMatch","getLine","getSelection","slice","match","add","handleCursorChange","handleTextChange","isHidden","focus","Error","offset","Text","pending","state","request","_isICompletionItemsConnector","then","reply","_validate","_onFetchItemsReply","_onFailure","_onReply","responseType","ICompletionItemsResponseType","_updateModel","cursor","matches","matchSet","Set","forEach","push","types","metadata","_jupyter_types_experimental","typeMap","item","has","setOptions","setCompletionItems","items","Message","KernelConnector","super","_session","session","async","_a","kernel","contents","code","cursor_pos","response","requestComplete","content","status","cursor_start","cursor_end","ContextConnector","resolve","Private","contextHint","token","getTokenForPosition","tokenList","getTokens","filter","t","indexOf","getCompletionTokens","completionList","map","Array","from","CompletionConnector","_kernel","_context","all","context","mergeReplies","memo","reduce","acc","Object","assign","CompleterModel","_current","_cursor","_completionItems","_options","_original","_query","_subsetMatch","_typeMap","_orderedTypes","_stateChanged","stateChanged","JSONExt","_reset","emit","undefined","current","originalLine","split","currentLine","query","substring","ending","lastIndexOf","completionItems","_markup","findOrderedCompletionItemTypes","_filter","iter","orderedTypes","values","toArray","findOrderedTypes","change","cursorDelta","inputDelta","last","hard","results","index","label","prefix","StringExt","marked","indices","mark","documentation","join","insertText","score","sort","scoreCmp2","x","option","raw","scoreCmp","result","KNOWN_TYPES","KNOWN_MAP","a","b","delta","localeCompare","_b","_c","newTypeSet","includes","newTypes","concat","filtered","keys","key","ITEM_CLASS","ACTIVE_CLASS","USE_CAPTURE","Completer","Widget","node","document","createElement","_activeIndex","_model","_resetFlag","_selected","_visibilityChanged","_indexChanged","_lastSubsetMatch","_renderer","renderer","defaultRenderer","addClass","activeIndex","indexChanged","onModelStateChanged","handleEvent","event","_evtKeydown","_evtMousedown","_evtScroll","selectActive","active","querySelector","getAttribute","onAfterAttach","addEventListener","onBeforeDetach","removeEventListener","isAttached","update","onUpdateRequest","hide","completionItemList","_createCompletionItemNode","_createIItemNode","querySelectorAll","docPanel","className","appendChild","_updateDocPanel","_populateSubset","show","_setGeometry","textContent","ul","createCompletionItemNode","li","createItemNode","_cycle","direction","boxHeight","getBoundingClientRect","height","itemHeight","pageLength","Math","floor","min","max","ElementExt","contains","target","keyCode","preventDefault","stopPropagation","stopImmediatePropagation","populated","shiftKey","cycle","keyCodeMap","nonstandardClick","documentElement","parentElement","requestAnimationFrame","subset","commonSubset","itemValues","anchor","getCoordinateForPosition","style","window","getComputedStyle","borderLeft","parseInt","borderLeftWidth","paddingLeft","HoverBox","maxHeight","minHeight","horizontal","privilege","setAttribute","activeItem","createDocumentationNode","Renderer","baseNode","_createBaseNode","deprecated","_constructNode","_createMatchNode","icon","pre","matchNode","innerHTML","defaultSanitizer","allowedTags","typesExist","iconNode","element","typeNode","toLowerCase","colorIndex","toString","dummyNode","title","typeExtendedNode","toLocaleLowerCase","dummyTypeExtendedNode","len","strlen","i","ch","j","attr","button","altKey","ctrlKey","metaKey","ICompletionManager","Token"],"sourceRoot":""}