{"version":3,"file":"143.b1e078f.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/codemirrorsearchprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/genericsearchprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/notebooksearchprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchoverlay.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchinstance.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchproviderregistry.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/tokens.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*\n  Parts of the implementation of the search in this file were derived from\n  CodeMirror's search at:\n  https://github.com/codemirror/CodeMirror/blob/c2676685866c571a1c9c82cb25018cc08b4d42b2/addon/search/search.js\n  which is licensed with the following license:\n\n  MIT License\n\n  Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\nimport { MainAreaWidget } from '@jupyterlab/apputils';\nimport { CodeMirrorEditor } from '@jupyterlab/codemirror';\nimport { FileEditor } from '@jupyterlab/fileeditor';\nimport { Signal } from '@lumino/signaling';\nimport * as CodeMirror from 'codemirror';\nexport class CodeMirrorSearchProvider {\n    constructor() {\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = false;\n        /**\n         * Set whether or not the CodemirrorSearchProvider will wrap to the beginning\n         * or end of the document on invocations of highlightNext or highlightPrevious, respectively\n         */\n        this.isSubProvider = false;\n        this._matchState = {};\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        const cm = searchTarget.content.editor;\n        const selection = cm.doc.getSelection();\n        // if there are newlines, just return empty string\n        return selection.search(/\\r?\\n|\\r/g) === -1 ? selection : '';\n    }\n    /**\n     * Initialize the search using the provided options.  Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     * @param [filters={}] Filter parameters to pass to provider\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget, filters = {}) {\n        if (!CodeMirrorSearchProvider.canSearchOn(searchTarget)) {\n            throw new Error('Cannot find Codemirror instance to search');\n        }\n        // canSearchOn is a type guard that guarantees the type of .editor\n        this._cm = searchTarget.content.editor;\n        return this._startQuery(query);\n    }\n    /**\n     * Initialize the search using a CodeMirrorEditor object.\n     */\n    async startQueryCodeMirror(query, searchTarget) {\n        this._cm = searchTarget;\n        return this._startQuery(query, false);\n    }\n    refreshOverlay() {\n        this._refreshOverlay();\n    }\n    async _startQuery(query, refreshOverlay = true) {\n        // no point in removing overlay in the middle of the search\n        await this.endQuery(false);\n        this._query = query;\n        CodeMirror.on(this._cm.doc, 'change', this._onDocChanged.bind(this));\n        if (refreshOverlay) {\n            this._refreshOverlay();\n        }\n        this._setInitialMatches(query);\n        const matches = this._parseMatchesFromState();\n        if (matches.length === 0) {\n            return [];\n        }\n        if (!this.isSubProvider) {\n            const cursorMatch = this._findNext(false);\n            const match = cursorMatch &&\n                this._matchState[cursorMatch.from.line][cursorMatch.from.ch];\n            this._currentMatch = match;\n        }\n        return matches;\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery(removeOverlay = true) {\n        this._matchState = {};\n        this._currentMatch = null;\n        if (removeOverlay) {\n            this._cm.removeOverlay(this._overlay);\n        }\n        const from = this._cm.getCursor('from');\n        const to = this._cm.getCursor('to');\n        // Setting a reverse selection to allow search-as-you-type to maintain the\n        // current selected match.  See comment in _findNext for more details.\n        if (from !== to) {\n            this._cm.setSelection({\n                start: this._toEditorPos(to),\n                end: this._toEditorPos(from)\n            });\n        }\n        CodeMirror.off(this._cm.doc, 'change', this._onDocChanged.bind(this));\n    }\n    /**\n     * Resets UI state, removes all matches.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        if (!this.isSubProvider) {\n            this._cm.focus();\n        }\n        return this.endQuery();\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        const cursorMatch = this._findNext(false);\n        if (!cursorMatch) {\n            return;\n        }\n        const match = this._matchState[cursorMatch.from.line][cursorMatch.from.ch];\n        this._currentMatch = match;\n        return match;\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        const cursorMatch = this._findNext(true);\n        if (!cursorMatch) {\n            return;\n        }\n        const match = this._matchState[cursorMatch.from.line][cursorMatch.from.ch];\n        this._currentMatch = match;\n        return match;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText) {\n        // If the current selection exactly matches the current match,\n        // replace it.  Otherwise, just select the next match after the cursor.\n        let replaceOccurred = false;\n        if (this._currentMatchIsSelected()) {\n            const cursor = this._cm.getSearchCursor(this._query, this._cm.getCursor('from'), !this._query.ignoreCase);\n            if (!cursor.findNext()) {\n                return replaceOccurred;\n            }\n            replaceOccurred = true;\n            cursor.replace(newText);\n        }\n        await this.highlightNext();\n        return replaceOccurred;\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        let replaceOccurred = false;\n        return new Promise((resolve, _) => {\n            this._cm.operation(() => {\n                const cursor = this._cm.getSearchCursor(this._query, undefined, !this._query.ignoreCase);\n                while (cursor.findNext()) {\n                    replaceOccurred = true;\n                    cursor.replace(newText);\n                }\n                this._matchState = {};\n                this._currentMatch = null;\n                resolve(replaceOccurred);\n            });\n        });\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        return (domain instanceof MainAreaWidget &&\n            domain.content instanceof FileEditor &&\n            domain.content.editor instanceof CodeMirrorEditor);\n    }\n    /**\n     * The same list of matches provided by the startQuery promise resolution\n     */\n    get matches() {\n        return this._parseMatchesFromState();\n    }\n    get currentMatch() {\n        return this._currentMatch;\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        if (!this._currentMatch) {\n            return null;\n        }\n        return this._currentMatch.index;\n    }\n    clearSelection() {\n        return undefined;\n    }\n    get editor() {\n        return this._cm;\n    }\n    _onDocChanged(_, changeObj) {\n        var _a, _b;\n        // If we get newlines added/removed, the line numbers across the\n        // match state are all shifted, so here we need to recalculate it\n        if (changeObj.text.length > 1 || ((_b = (_a = changeObj.removed) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 1) {\n            this._setInitialMatches(this._query);\n            this._changed.emit(undefined);\n        }\n    }\n    _refreshOverlay() {\n        this._cm.operation(() => {\n            // clear search first\n            this._cm.removeOverlay(this._overlay);\n            this._overlay = this._getSearchOverlay();\n            this._cm.addOverlay(this._overlay);\n            this._changed.emit(undefined);\n        });\n    }\n    /**\n     * Do a full search on the entire document.\n     *\n     * This manually constructs the initial match state across the whole\n     * document. This must be done manually because the codemirror overlay\n     * is lazy-loaded, so it will only tokenize lines that are in or near\n     * the viewport.  This is sufficient for efficiently maintaining the\n     * state when changes are made to the document, as changes occur in or\n     * near the viewport, but to scan the whole document, a manual search\n     * across the entire content is required.\n     *\n     * @param query The search term\n     */\n    _setInitialMatches(query) {\n        this._matchState = {};\n        const start = CodeMirror.Pos(this._cm.doc.firstLine(), 0);\n        const end = CodeMirror.Pos(this._cm.doc.lastLine());\n        const content = this._cm.doc.getRange(start, end);\n        const lines = content.split('\\n');\n        const totalMatchIndex = 0;\n        lines.forEach((line, lineNumber) => {\n            query.lastIndex = 0;\n            let match = query.exec(line);\n            while (match) {\n                const col = match.index;\n                const matchObj = {\n                    text: match[0],\n                    line: lineNumber,\n                    column: col,\n                    fragment: line,\n                    index: totalMatchIndex\n                };\n                if (!this._matchState[lineNumber]) {\n                    this._matchState[lineNumber] = {};\n                }\n                this._matchState[lineNumber][col] = matchObj;\n                match = query.exec(line);\n            }\n        });\n    }\n    _getSearchOverlay() {\n        return {\n            /**\n             * Token function is called when a line needs to be processed -\n             * when the overlay is initially created, it's called on all lines;\n             * when a line is modified and needs to be re-evaluated, it's called\n             * on just that line.\n             *\n             * This implementation of the token function both constructs/maintains\n             * the overlay and keeps track of the match state as the document is\n             * updated while a search is active.\n             */\n            token: (stream) => {\n                const currentPos = stream.pos;\n                this._query.lastIndex = currentPos;\n                const lineText = stream.string;\n                const match = this._query.exec(lineText);\n                const line = stream.lineOracle.line;\n                // If starting at position 0, the tokenization of this line has just started.\n                // Blow away everything on this line in the state so it can be updated.\n                if (stream.start === currentPos &&\n                    currentPos === 0 &&\n                    !!this._matchState[line]) {\n                    this._matchState[line] = {};\n                }\n                if (match && match.index === currentPos) {\n                    // found match, add it to state\n                    const matchLength = match[0].length;\n                    const matchObj = {\n                        text: lineText.substr(currentPos, matchLength),\n                        line: line,\n                        column: currentPos,\n                        fragment: lineText,\n                        index: 0 // fill in index when flattening, later\n                    };\n                    if (!this._matchState[line]) {\n                        this._matchState[line] = {};\n                    }\n                    this._matchState[line][currentPos] = matchObj;\n                    // move the stream along and return searching style for the token\n                    stream.pos += matchLength || 1;\n                    // if the last thing on the line was a match, make sure we still\n                    // emit the changed signal so the display can pick up the updates\n                    if (stream.eol()) {\n                        this._changed.emit(undefined);\n                    }\n                    return 'searching';\n                }\n                else if (match) {\n                    // there's a match in the stream, advance the stream to its position\n                    stream.pos = match.index;\n                }\n                else {\n                    // no matches, consume the rest of the stream\n                    this._changed.emit(undefined);\n                    stream.skipToEnd();\n                }\n            }\n        };\n    }\n    _findNext(reverse) {\n        return this._cm.operation(() => {\n            const caseSensitive = this._query.ignoreCase;\n            // In order to support search-as-you-type, we needed a way to allow the first\n            // match to be selected when a search is started, but prevent the selected\n            // search to move for each new keypress.  To do this, when a search is ended,\n            // the cursor is reversed, putting the head at the 'from' position.  When a new\n            // search is started, the cursor we want is at the 'from' position, so that the same\n            // match is selected when the next key is entered (if it is still a match).\n            //\n            // When toggling through a search normally, the cursor is always set in the forward\n            // direction, so head is always at the 'to' position.  That way, if reverse = false,\n            // the search proceeds from the 'to' position during normal toggling.  If reverse = true,\n            // the search always proceeds from the 'anchor' position, which is at the 'from'.\n            const cursorToGet = reverse ? 'anchor' : 'head';\n            const lastPosition = this._cm.getCursor(cursorToGet);\n            const position = this._toEditorPos(lastPosition);\n            let cursor = this._cm.getSearchCursor(this._query, lastPosition, !caseSensitive);\n            if (!cursor.find(reverse)) {\n                // if we don't want to loop, no more matches found, reset the cursor and exit\n                if (this.isSubProvider) {\n                    this._cm.setCursorPosition(position, { scroll: false });\n                    this._currentMatch = null;\n                    return null;\n                }\n                // if we do want to loop, try searching from the bottom/top\n                const startOrEnd = reverse\n                    ? CodeMirror.Pos(this._cm.lastLine())\n                    : CodeMirror.Pos(this._cm.firstLine(), 0);\n                cursor = this._cm.getSearchCursor(this._query, startOrEnd, !caseSensitive);\n                if (!cursor.find(reverse)) {\n                    return null;\n                }\n            }\n            const fromPos = cursor.from();\n            const toPos = cursor.to();\n            const selRange = {\n                start: {\n                    line: fromPos.line,\n                    column: fromPos.ch\n                },\n                end: {\n                    line: toPos.line,\n                    column: toPos.ch\n                }\n            };\n            this._cm.setSelection(selRange);\n            this._cm.scrollIntoView({\n                from: fromPos,\n                to: toPos\n            }, 100);\n            return {\n                from: fromPos,\n                to: toPos\n            };\n        });\n    }\n    _parseMatchesFromState() {\n        let index = 0;\n        // Flatten state map and update the index of each match\n        const matches = Object.keys(this._matchState).reduce((result, lineNumber) => {\n            const lineKey = parseInt(lineNumber, 10);\n            const lineMatches = this._matchState[lineKey];\n            Object.keys(lineMatches).forEach((pos) => {\n                const posKey = parseInt(pos, 10);\n                const match = lineMatches[posKey];\n                match.index = index;\n                index += 1;\n                result.push(match);\n            });\n            return result;\n        }, []);\n        return matches;\n    }\n    _toEditorPos(posIn) {\n        return {\n            line: posIn.line,\n            column: posIn.ch\n        };\n    }\n    _currentMatchIsSelected() {\n        if (!this._currentMatch) {\n            return false;\n        }\n        const currentSelection = this._cm.getSelection();\n        const currentSelectionLength = currentSelection.end.column - currentSelection.start.column;\n        const selectionIsOneLine = currentSelection.start.line === currentSelection.end.line;\n        return (this._currentMatch.line === currentSelection.start.line &&\n            this._currentMatch.column === currentSelection.start.column &&\n            this._currentMatch.text.length === currentSelectionLength &&\n            selectionIsOneLine);\n    }\n}\nexport class SearchState {\n}\n//# sourceMappingURL=codemirrorsearchprovider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\nexport const FOUND_CLASSES = ['cm-string', 'cm-overlay', 'cm-searching'];\nconst SELECTED_CLASSES = ['CodeMirror-selectedtext'];\nexport class GenericSearchProvider {\n    constructor() {\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = true;\n        /**\n         * Set whether or not this will wrap to the beginning\n         * or end of the document on invocations of highlightNext or highlightPrevious, respectively\n         */\n        this.isSubProvider = false;\n        this._matches = [];\n        this._mutationObserver = new MutationObserver(this._onWidgetChanged.bind(this));\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        return '';\n    }\n    /**\n     * Initialize the search using the provided options.  Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     * @param [filters={}] Filter parameters to pass to provider\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget, filters = {}) {\n        const that = this; // eslint-disable-line\n        // No point in removing overlay in the middle of the search\n        await this.endQuery(false);\n        this._widget = searchTarget;\n        this._query = query;\n        this._mutationObserver.disconnect();\n        const matches = [];\n        const walker = document.createTreeWalker(this._widget.node, NodeFilter.SHOW_TEXT, {\n            acceptNode: node => {\n                // Filter subtrees of UNSUPPORTED_ELEMENTS and nodes that\n                // do not contain our search text\n                let parentElement = node.parentElement;\n                while (parentElement !== this._widget.node) {\n                    if (parentElement.nodeName in\n                        GenericSearchProvider.UNSUPPORTED_ELEMENTS) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n                return that._query.test(node.textContent)\n                    ? NodeFilter.FILTER_ACCEPT\n                    : NodeFilter.FILTER_REJECT;\n            }\n        }, false);\n        const nodes = [];\n        const originalNodes = [];\n        // We MUST gather nodes first, otherwise the updates below will find each result twice\n        let node = walker.nextNode();\n        while (node) {\n            nodes.push(node);\n            /* We store them here as we want to avoid saving a modified one\n             * This happens with something like this: <pre><span>Hello</span> world</pre> and looking for o\n             * The o in world is found after the o in hello which means the pre could have been modified already\n             * While there may be a better data structure to do this for performance, this was easy to reason about.\n             */\n            originalNodes.push(node.parentElement.cloneNode(true));\n            node = walker.nextNode();\n        }\n        // We'll need to copy the regexp to ensure its 'g' and that we start the index count from 0\n        const flags = this._query.flags.indexOf('g') === -1 ? query.flags + 'g' : query.flags;\n        nodes.forEach((node, nodeIndex) => {\n            const q = new RegExp(query.source, flags);\n            const subsections = [];\n            let match = q.exec(node.textContent);\n            while (match) {\n                subsections.push({\n                    start: match.index,\n                    end: match.index + match[0].length,\n                    text: match[0]\n                });\n                match = q.exec(node.textContent);\n            }\n            const originalNode = originalNodes[nodeIndex];\n            const originalLength = node.textContent.length; // Node length will change below\n            let lastNodeAdded = null;\n            // Go backwards as index may change if we go forwards\n            const newMatches = [];\n            for (let idx = subsections.length - 1; idx >= 0; --idx) {\n                const { start, end, text } = subsections[idx];\n                // TODO: support tspan for svg when svg support is added\n                const spannedNode = document.createElement('span');\n                spannedNode.classList.add(...FOUND_CLASSES);\n                spannedNode.textContent = text;\n                // Splice the text out before we add it back in with a span\n                node.textContent = `${node.textContent.slice(0, start)}${node.textContent.slice(end)}`;\n                // Are we replacing somewhere in the middle?\n                if ((node === null || node === void 0 ? void 0 : node.nodeType) == Node.TEXT_NODE) {\n                    const endText = node.splitText(start);\n                    node.parentNode.insertBefore(spannedNode, endText);\n                    // Are we replacing from the start?\n                }\n                else if (start === 0) {\n                    node.parentNode.prepend(spannedNode);\n                    // Are we replacing at the end?\n                }\n                else if (end === originalLength) {\n                    node.parentNode.append(spannedNode);\n                    // Are the two results are adjacent to each other?\n                }\n                else if (lastNodeAdded && end === subsections[idx + 1].start) {\n                    node.parentNode.insertBefore(spannedNode, lastNodeAdded);\n                }\n                lastNodeAdded = spannedNode;\n                newMatches.unshift({\n                    text,\n                    fragment: '',\n                    line: 0,\n                    column: 0,\n                    index: -1,\n                    // GenericSearchFields\n                    matchesIndex: -1,\n                    indexInOriginal: idx,\n                    spanElement: spannedNode,\n                    originalNode\n                });\n            }\n            matches.push(...newMatches);\n        });\n        matches.forEach((match, idx) => {\n            // This may be changed when this is a subprovider :/\n            match.index = idx;\n            // TODO: matchesIndex is declared as readonly. Why are we setting it here?\n            match.matchesIndex = idx;\n        });\n        if (!this.isSubProvider && matches.length > 0) {\n            this._currentMatch = matches[0];\n        }\n        // Watch for future changes:\n        this._mutationObserver.observe(this._widget.node, \n        // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit\n        {\n            attributes: false,\n            characterData: true,\n            childList: true,\n            subtree: true\n        });\n        this._matches = matches;\n        return this._matches;\n    }\n    refreshOverlay() {\n        // We don't have an overlay, we are directly changing the DOM\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery(removeOverlay = true) {\n        this._matches.forEach(match => {\n            // We already took care of this parent with another match\n            if (match.indexInOriginal !== 0) {\n                return;\n            }\n            match.spanElement.parentElement.replaceWith(match.originalNode);\n        });\n        this._matches = [];\n        this._currentMatch = null;\n        this._mutationObserver.disconnect();\n    }\n    /**\n     * Resets UI state, removes all matches.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        return this.endQuery();\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        return this._highlightNext(false);\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        return this._highlightNext(true);\n    }\n    _highlightNext(reverse) {\n        if (this._matches.length === 0) {\n            return undefined;\n        }\n        if (!this._currentMatch) {\n            this._currentMatch = reverse\n                ? this._matches[this.matches.length - 1]\n                : this._matches[0];\n        }\n        else {\n            this._currentMatch.spanElement.classList.remove(...SELECTED_CLASSES);\n            let nextIndex = reverse\n                ? this._currentMatch.matchesIndex - 1\n                : this._currentMatch.matchesIndex + 1;\n            // When we are a subprovider, don't loop\n            if (this.isSubProvider) {\n                if (nextIndex < 0 || nextIndex >= this._matches.length) {\n                    this._currentMatch = null;\n                    return undefined;\n                }\n            }\n            // Cheap way to make this a circular buffer\n            nextIndex = (nextIndex + this._matches.length) % this._matches.length;\n            this._currentMatch = this._matches[nextIndex];\n        }\n        if (this._currentMatch) {\n            this._currentMatch.spanElement.classList.add(...SELECTED_CLASSES);\n            // If not in view, scroll just enough to see it\n            if (!elementInViewport(this._currentMatch.spanElement)) {\n                this._currentMatch.spanElement.scrollIntoView(reverse);\n            }\n            this._currentMatch.spanElement.focus();\n        }\n        return this._currentMatch;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText) {\n        return Promise.resolve(false);\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        // This is read only, but we could loosen this in theory for input boxes...\n        return Promise.resolve(false);\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        return domain instanceof Widget;\n    }\n    /**\n     * The same list of matches provided by the startQuery promise resolution\n     */\n    get matches() {\n        // Ensure that no other fn can overwrite matches index property\n        // We shallow clone each node\n        return this._matches\n            ? this._matches.map(m => Object.assign({}, m))\n            : this._matches;\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        if (!this._currentMatch) {\n            return null;\n        }\n        return this._currentMatch.index;\n    }\n    get currentMatch() {\n        return this._currentMatch;\n    }\n    clearSelection() {\n        return;\n    }\n    async _onWidgetChanged(mutations, observer) {\n        // This is typically cheap, but we do not control the rate of change or size of the output\n        await this.startQuery(this._query, this._widget);\n        this._changed.emit(undefined);\n    }\n}\n/**\n * We choose opt out as most node types should be searched (e.g. script).\n * Even nodes like <data>, could have textContent we care about.\n *\n * Note: nodeName is capitalized, so we do the same here\n */\nGenericSearchProvider.UNSUPPORTED_ELEMENTS = {\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Document_metadata\n    BASE: true,\n    HEAD: true,\n    LINK: true,\n    META: true,\n    STYLE: true,\n    TITLE: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Sectioning_root\n    BODY: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Content_sectioning\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Text_content\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Inline_text_semantics\n    // Above is searched\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Image_and_multimedia\n    AREA: true,\n    AUDIO: true,\n    IMG: true,\n    MAP: true,\n    TRACK: true,\n    VIDEO: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Embedded_content\n    APPLET: true,\n    EMBED: true,\n    IFRAME: true,\n    NOEMBED: true,\n    OBJECT: true,\n    PARAM: true,\n    PICTURE: true,\n    SOURCE: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Scripting\n    CANVAS: true,\n    NOSCRIPT: true,\n    SCRIPT: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Demarcating_edits\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Table_content\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Forms\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Interactive_elements\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Web_Components\n    // Above is searched\n    // Other:\n    SVG: true\n};\nfunction elementInViewport(el) {\n    const boundingClientRect = el.getBoundingClientRect();\n    return (boundingClientRect.top >= 0 &&\n        boundingClientRect.bottom <=\n            (window.innerHeight || document.documentElement.clientHeight) &&\n        boundingClientRect.left >= 0 &&\n        boundingClientRect.right <=\n            (window.innerWidth || document.documentElement.clientWidth));\n}\n//# sourceMappingURL=genericsearchprovider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { CodeCell, MarkdownCell } from '@jupyterlab/cells';\nimport { NotebookPanel } from '@jupyterlab/notebook';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\nimport CodeMirror from 'codemirror';\nimport { CodeMirrorSearchProvider } from './codemirrorsearchprovider';\nimport { GenericSearchProvider } from './genericsearchprovider';\nexport class NotebookSearchProvider {\n    constructor() {\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = false;\n        this.hasOutputs = true;\n        this._searchProviders = [];\n        this._unRenderedMarkdownCells = [];\n        this._cellsWithMatches = [];\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        var _a;\n        const activeCell = searchTarget.content.activeCell;\n        const selection = (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.editor) === null || _a === void 0 ? void 0 : _a.doc.getSelection();\n        // if there are newlines, just return empty string\n        return (selection === null || selection === void 0 ? void 0 : selection.search(/\\r?\\n|\\r/g)) === -1 ? selection : '';\n    }\n    /**\n     * Initialize the search using the provided options. Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     * @param filters Filter parameters to pass to provider\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget, filters) {\n        this._searchTarget = searchTarget;\n        let cells = this._searchTarget.content.widgets;\n        this._filters =\n            !filters || Object.entries(filters).length === 0\n                ? { output: true, selectedCells: false }\n                : filters;\n        const selectedCells = cells.filter(cell => this._searchTarget.content.isSelectedOrActive(cell));\n        if (this._filters.selectedCells && selectedCells.length > 0) {\n            cells = selectedCells;\n        }\n        // hide the current notebook widget to prevent expensive layout re-calculation operations\n        this._searchTarget.hide();\n        let indexTotal = 0;\n        const allMatches = [];\n        // For each cell, create a search provider and collect the matches\n        for (const cell of cells) {\n            const cmEditor = cell.editor;\n            const cmSearchProvider = new CodeMirrorSearchProvider();\n            cmSearchProvider.isSubProvider = true;\n            // If a rendered MarkdownCell contains a match, unrender it so that\n            // CodeMirror can show the match(es).  If the MarkdownCell is not\n            // rendered, putting CodeMirror on the page, CodeMirror will not run\n            // the mode, which will prevent the search from occurring.\n            // Keep track so that the cell can be rerendered when the search is ended\n            // or if there are no matches\n            let cellShouldReRender = false;\n            if (cell instanceof MarkdownCell && cell.rendered) {\n                cell.rendered = false;\n                cellShouldReRender = true;\n            }\n            // Unhide hidden cells for the same reason as above\n            if (cell.inputHidden) {\n                cell.inputHidden = false;\n            }\n            // chain promises to ensure indexing is sequential\n            const matchesFromCell = await cmSearchProvider.startQueryCodeMirror(query, cmEditor);\n            if (cell instanceof MarkdownCell) {\n                if (matchesFromCell.length !== 0) {\n                    // un-render markdown cells with matches\n                    this._unRenderedMarkdownCells.push(cell);\n                }\n                else if (cellShouldReRender) {\n                    // was rendered previously, no need to refresh\n                    cell.rendered = true;\n                }\n            }\n            if (matchesFromCell.length !== 0) {\n                cmSearchProvider.refreshOverlay();\n                this._cellsWithMatches.push(cell);\n            }\n            // update the match indices to reflect the whole document index values\n            matchesFromCell.forEach(match => {\n                match.index = match.index + indexTotal;\n            });\n            indexTotal += matchesFromCell.length;\n            // search has been initialized, connect the changed signal\n            cmSearchProvider.changed.connect(this._onSearchProviderChanged, this);\n            allMatches.concat(matchesFromCell);\n            this._searchProviders.push({\n                cell: cell,\n                provider: cmSearchProvider\n            });\n            if (cell instanceof CodeCell && this._filters.output) {\n                const outputProvider = new GenericSearchProvider();\n                outputProvider.isSubProvider = true;\n                const matchesFromOutput = await outputProvider.startQuery(query, cell.outputArea);\n                matchesFromOutput.map(match => {\n                    match.index = match.index + indexTotal;\n                });\n                indexTotal += matchesFromOutput.length;\n                allMatches.concat(matchesFromOutput);\n                outputProvider.changed.connect(this._onSearchProviderChanged, this);\n                this._searchProviders.push({\n                    cell: cell,\n                    provider: outputProvider\n                });\n            }\n        }\n        // show the widget again, recalculation of layout will matter again\n        // and so that the next step will scroll correctly to the first match\n        this._searchTarget.show();\n        this._currentMatch = await this._stepNext(this._updatedCurrentProvider(false));\n        this._refreshCurrentCellEditor();\n        this._refreshCellsEditorsInBackground(this._cellsWithMatches);\n        return allMatches;\n    }\n    /**\n     * Gradually refresh cells in the background so that the user will not\n     * experience frozen interface, `n` cells at a time.\n     */\n    _refreshCellsEditorsInBackground(cells, n = 5) {\n        let i = 0;\n        const refreshNextNCells = () => {\n            for (let stop = i + n; i < stop && i < cells.length; i++) {\n                cells[i].editor.refresh();\n            }\n            if (i < cells.length) {\n                window.setTimeout(refreshNextNCells, 0);\n            }\n        };\n        window.setTimeout(refreshNextNCells, 0);\n    }\n    /**\n     * Refresh the editor in the cell for the current match.\n     */\n    _refreshCurrentCellEditor() {\n        const notebook = this._searchTarget.content;\n        notebook.activeCell.editor.refresh();\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery() {\n        this._searchTarget.hide();\n        const queriesEnded = [];\n        this._searchProviders.forEach(({ provider }) => {\n            queriesEnded.push(provider.endQuery());\n            provider.changed.disconnect(this._onSearchProviderChanged, this);\n        });\n        Signal.disconnectBetween(this._searchTarget.model.cells, this);\n        this._searchProviders = [];\n        this._currentProvider = null;\n        this._unRenderedMarkdownCells.forEach((cell) => {\n            // Guard against the case where markdown cells have been deleted\n            if (!cell.isDisposed) {\n                cell.rendered = true;\n            }\n        });\n        this._unRenderedMarkdownCells = [];\n        await Promise.all(queriesEnded);\n        this._searchTarget.show();\n        this._refreshCurrentCellEditor();\n        // re-render all non-markdown cells with matches (which were rendered, thus do not need refreshing)\n        this._refreshCellsEditorsInBackground(this._cellsWithMatches.filter((cell) => !(cell instanceof MarkdownCell)));\n        this._cellsWithMatches = [];\n    }\n    /**\n     * Resets UI state, removes all matches.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        this._searchTarget.hide();\n        Signal.disconnectBetween(this._searchTarget.model.cells, this);\n        const index = this._searchTarget.content.activeCellIndex;\n        const searchEnded = [];\n        this._searchProviders.forEach(({ provider }) => {\n            searchEnded.push(provider.endSearch());\n            provider.changed.disconnect(this._onSearchProviderChanged, this);\n        });\n        this._searchProviders = [];\n        this._currentProvider = null;\n        this._unRenderedMarkdownCells.forEach((cell) => {\n            cell.rendered = true;\n        });\n        this._unRenderedMarkdownCells = [];\n        this._searchTarget.content.activeCellIndex = index;\n        this._searchTarget.content.mode = 'edit';\n        this._currentMatch = null;\n        await Promise.all(searchEnded);\n        this._searchTarget.show();\n        this._refreshCurrentCellEditor();\n        this._searchTarget = null;\n        // re-render all non-markdown cells with matches (which were rendered, thus do not need refreshing)\n        this._refreshCellsEditorsInBackground(this._cellsWithMatches.filter((cell) => !(cell instanceof MarkdownCell)));\n        this._cellsWithMatches = [];\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        this._currentMatch = await this._stepNext(this._updatedCurrentProvider(false));\n        return this._currentMatch;\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        this._currentMatch = await this._stepNext(this._updatedCurrentProvider(true), true);\n        return this._currentMatch;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText) {\n        const notebook = this._searchTarget.content;\n        const editor = notebook.activeCell.editor;\n        let replaceOccurred = false;\n        if (this._currentMatchIsSelected(editor)) {\n            const { provider } = this._currentProvider;\n            replaceOccurred = await provider.replaceCurrentMatch(newText);\n            if (replaceOccurred) {\n                this._currentMatch = provider.currentMatch;\n                // If there was a replacement and there is another match, then the CodeMirrorSearchProvider\n                // already highlighted the next match, so we can return early to avoid skipping a match.\n                if (this._currentMatch) {\n                    return replaceOccurred;\n                }\n            }\n        }\n        await this.highlightNext();\n        return replaceOccurred;\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        let replaceOccurred = false;\n        for (const index in this._searchProviders) {\n            const { provider } = this._searchProviders[index];\n            const singleReplaceOccurred = await provider.replaceAllMatches(newText);\n            replaceOccurred = singleReplaceOccurred ? true : replaceOccurred;\n        }\n        this._currentMatch = null;\n        return replaceOccurred;\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        // check to see if the CMSearchProvider can search on the\n        // first cell, false indicates another editor is present\n        return domain instanceof NotebookPanel;\n    }\n    /**\n     * The same list of matches provided by the startQuery promise resolution\n     */\n    get matches() {\n        return [].concat(...this._getMatchesFromCells());\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        if (!this._currentMatch) {\n            return null;\n        }\n        return this._currentMatch.index;\n    }\n    _updatedCurrentProvider(reverse) {\n        if (this._currentProvider &&\n            this._currentProvider.cell === this._searchTarget.content.activeCell) {\n            return this._currentProvider;\n        }\n        let provider;\n        if (!this._currentProvider) {\n            const find = reverse ? ArrayExt.findLastValue : ArrayExt.findFirstValue;\n            provider = find(this._searchProviders, provider => this._searchTarget.content.activeCell === provider.cell);\n        }\n        else {\n            const currentProviderIndex = ArrayExt.firstIndexOf(this._searchProviders, this._currentProvider);\n            const nextProviderIndex = ((reverse ? currentProviderIndex - 1 : currentProviderIndex + 1) +\n                this._searchProviders.length) %\n                this._searchProviders.length;\n            provider = this._searchProviders[nextProviderIndex];\n        }\n        this._currentProvider = provider;\n        return provider;\n    }\n    async _stepNext(currentSearchPair, reverse = false, steps = 0) {\n        const { provider } = currentSearchPair;\n        // highlightNext/Previous will not be able to search rendered MarkdownCells or\n        // hidden code cells, but that is okay here because in startQuery, we unrendered\n        // all cells with matches and unhide all cells\n        const match = reverse\n            ? await provider.highlightPrevious()\n            : await provider.highlightNext();\n        // If there was no match in this cell, try the next cell\n        if (!match) {\n            const providerIndex = this._searchProviders.indexOf(currentSearchPair);\n            const numProviders = this._searchProviders.length;\n            // We have looped around the whole notebook and have searched the original\n            // cell once more and found no matches.  Do not proceed with incrementing the\n            // active cell index so that the active cell doesn't change\n            if (steps === numProviders) {\n                return undefined;\n            }\n            const nextIndex = ((reverse ? providerIndex - 1 : providerIndex + 1) + numProviders) %\n                numProviders;\n            const nextSearchPair = this._searchProviders[nextIndex];\n            if (nextSearchPair.provider instanceof CodeMirrorSearchProvider) {\n                const editor = nextSearchPair.provider.editor;\n                // move the cursor of the next cell to the start/end of the cell so it can\n                // search the whole thing (but don't scroll because we haven't found anything yet)\n                const newPosCM = reverse\n                    ? CodeMirror.Pos(editor.lastLine())\n                    : CodeMirror.Pos(editor.firstLine(), 0);\n                const newPos = {\n                    line: newPosCM.line,\n                    column: newPosCM.ch\n                };\n                editor.setCursorPosition(newPos, { scroll: false });\n            }\n            this._currentProvider = nextSearchPair;\n            return this._stepNext(nextSearchPair, reverse, steps + 1);\n        }\n        const notebook = this._searchTarget.content;\n        notebook.activeCellIndex = notebook.widgets.indexOf(currentSearchPair.cell);\n        return match;\n    }\n    _getMatchesFromCells() {\n        let indexTotal = 0;\n        const result = [];\n        this._searchProviders.forEach(({ provider }) => {\n            const cellMatches = provider.matches;\n            cellMatches.forEach(match => {\n                match.index = match.index + indexTotal;\n            });\n            indexTotal += cellMatches.length;\n            result.push(cellMatches);\n        });\n        return result;\n    }\n    _onSearchProviderChanged() {\n        this._changed.emit(undefined);\n    }\n    _currentMatchIsSelected(cm) {\n        if (!this._currentMatch) {\n            return false;\n        }\n        const currentSelection = cm.getSelection();\n        const currentSelectionLength = currentSelection.end.column - currentSelection.start.column;\n        const selectionIsOneLine = currentSelection.start.line === currentSelection.end.line;\n        return (this._currentMatch.line === currentSelection.start.line &&\n            this._currentMatch.column === currentSelection.start.column &&\n            this._currentMatch.text.length === currentSelectionLength &&\n            selectionIsOneLine);\n    }\n}\n//# sourceMappingURL=notebooksearchprovider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ReactWidget, UseSignal } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { caretDownEmptyThinIcon, caretDownIcon, caretRightIcon, caretUpEmptyThinIcon, caseSensitiveIcon, classes, closeIcon, ellipsesIcon, regexIcon } from '@jupyterlab/ui-components';\nimport { Debouncer } from '@lumino/polling';\nimport * as React from 'react';\nconst OVERLAY_CLASS = 'jp-DocumentSearch-overlay';\nconst OVERLAY_ROW_CLASS = 'jp-DocumentSearch-overlay-row';\nconst INPUT_CLASS = 'jp-DocumentSearch-input';\nconst INPUT_WRAPPER_CLASS = 'jp-DocumentSearch-input-wrapper';\nconst INPUT_BUTTON_CLASS_OFF = 'jp-DocumentSearch-input-button-off';\nconst INPUT_BUTTON_CLASS_ON = 'jp-DocumentSearch-input-button-on';\nconst INDEX_COUNTER_CLASS = 'jp-DocumentSearch-index-counter';\nconst UP_DOWN_BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-up-down-wrapper';\nconst UP_DOWN_BUTTON_CLASS = 'jp-DocumentSearch-up-down-button';\nconst ELLIPSES_BUTTON_CLASS = 'jp-DocumentSearch-ellipses-button';\nconst ELLIPSES_BUTTON_ENABLED_CLASS = 'jp-DocumentSearch-ellipses-button-enabled';\nconst REGEX_ERROR_CLASS = 'jp-DocumentSearch-regex-error';\nconst SEARCH_OPTIONS_CLASS = 'jp-DocumentSearch-search-options';\nconst SEARCH_OPTIONS_DISABLED_CLASS = 'jp-DocumentSearch-search-options-disabled';\nconst SEARCH_DOCUMENT_LOADING = 'jp-DocumentSearch-document-loading';\nconst REPLACE_ENTRY_CLASS = 'jp-DocumentSearch-replace-entry';\nconst REPLACE_BUTTON_CLASS = 'jp-DocumentSearch-replace-button';\nconst REPLACE_BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-replace-button-wrapper';\nconst REPLACE_WRAPPER_CLASS = 'jp-DocumentSearch-replace-wrapper-class';\nconst REPLACE_TOGGLE_CLASS = 'jp-DocumentSearch-replace-toggle';\nconst FOCUSED_INPUT = 'jp-DocumentSearch-focused-input';\nconst TOGGLE_WRAPPER = 'jp-DocumentSearch-toggle-wrapper';\nconst TOGGLE_PLACEHOLDER = 'jp-DocumentSearch-toggle-placeholder';\nconst BUTTON_CONTENT_CLASS = 'jp-DocumentSearch-button-content';\nconst BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-button-wrapper';\nconst SPACER_CLASS = 'jp-DocumentSearch-spacer';\nclass SearchEntry extends React.Component {\n    constructor(props) {\n        super(props);\n        this.translator = props.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this.searchInputRef = React.createRef();\n    }\n    /**\n     * Focus the input.\n     */\n    focusInput() {\n        var _a;\n        // Select (and focus) any text already present.\n        // This makes typing in the box starts a new query (the common case),\n        // while arrow keys can be used to move cursor in preparation for\n        // modifying previous query.\n        (_a = this.searchInputRef.current) === null || _a === void 0 ? void 0 : _a.select();\n    }\n    componentDidUpdate() {\n        if (this.props.forceFocus) {\n            this.focusInput();\n        }\n    }\n    render() {\n        const caseButtonToggleClass = classes(this.props.caseSensitive ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n        const regexButtonToggleClass = classes(this.props.useRegex ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n        const wrapperClass = `${INPUT_WRAPPER_CLASS} ${this.props.inputFocused ? FOCUSED_INPUT : ''}`;\n        return (React.createElement(\"div\", { className: wrapperClass },\n            React.createElement(\"input\", { placeholder: this.props.searchText ? undefined : this._trans.__('Find'), className: INPUT_CLASS, value: this.props.searchText, onChange: e => this.props.onChange(e), onKeyDown: e => this.props.onKeydown(e), tabIndex: 0, onFocus: e => this.props.onInputFocus(), onBlur: e => this.props.onInputBlur(), ref: this.searchInputRef }),\n            React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this.props.onCaseSensitiveToggled(), tabIndex: 0 },\n                React.createElement(caseSensitiveIcon.react, { className: caseButtonToggleClass, tag: \"span\" })),\n            React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this.props.onRegexToggled(), tabIndex: 0 },\n                React.createElement(regexIcon.react, { className: regexButtonToggleClass, tag: \"span\" }))));\n    }\n}\nclass ReplaceEntry extends React.Component {\n    constructor(props) {\n        super(props);\n        this._trans = (props.translator || nullTranslator).load('jupyterlab');\n        this.replaceInputRef = React.createRef();\n    }\n    render() {\n        return (React.createElement(\"div\", { className: REPLACE_WRAPPER_CLASS },\n            React.createElement(\"input\", { placeholder: this.props.replaceText ? undefined : this._trans.__('Replace'), className: REPLACE_ENTRY_CLASS, value: this.props.replaceText, onKeyDown: e => this.props.onReplaceKeydown(e), onChange: e => this.props.onChange(e), tabIndex: 0, ref: this.replaceInputRef }),\n            React.createElement(\"button\", { className: REPLACE_BUTTON_WRAPPER_CLASS, onClick: () => this.props.onReplaceCurrent(), tabIndex: 0 },\n                React.createElement(\"span\", { className: `${REPLACE_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`, tabIndex: 0 }, this._trans.__('Replace'))),\n            React.createElement(\"button\", { className: REPLACE_BUTTON_WRAPPER_CLASS, tabIndex: 0, onClick: () => this.props.onReplaceAll() },\n                React.createElement(\"span\", { className: `${REPLACE_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`, tabIndex: -1 }, this._trans.__('Replace All')))));\n    }\n}\nfunction UpDownButtons(props) {\n    return (React.createElement(\"div\", { className: UP_DOWN_BUTTON_WRAPPER_CLASS },\n        React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.onHighlightPrevious(), tabIndex: 0 },\n            React.createElement(caretUpEmptyThinIcon.react, { className: classes(UP_DOWN_BUTTON_CLASS, BUTTON_CONTENT_CLASS), tag: \"span\" })),\n        React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.onHighlightNext(), tabIndex: 0 },\n            React.createElement(caretDownEmptyThinIcon.react, { className: classes(UP_DOWN_BUTTON_CLASS, BUTTON_CONTENT_CLASS), tag: \"span\" }))));\n}\nfunction SearchIndices(props) {\n    return (React.createElement(\"div\", { className: INDEX_COUNTER_CLASS }, props.totalMatches === 0\n        ? '-/-'\n        : `${props.currentIndex === null ? '-' : props.currentIndex + 1}/${props.totalMatches}`));\n}\nclass FilterToggle extends React.Component {\n    render() {\n        let className = `${ELLIPSES_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`;\n        if (this.props.enabled) {\n            className = `${className} ${ELLIPSES_BUTTON_ENABLED_CLASS}`;\n        }\n        return (React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this.props.toggleEnabled(), tabIndex: 0 },\n            React.createElement(ellipsesIcon.react, { className: className, tag: \"span\", height: \"20px\", width: \"20px\" })));\n    }\n}\nclass FilterSelection extends React.Component {\n    render() {\n        return (React.createElement(\"label\", { className: SEARCH_OPTIONS_CLASS },\n            React.createElement(\"div\", null,\n                React.createElement(\"span\", { className: this.props.canToggleOutput ? '' : SEARCH_OPTIONS_DISABLED_CLASS }, this.props.trans.__('Search Cell Outputs')),\n                React.createElement(\"input\", { type: \"checkbox\", disabled: !this.props.canToggleOutput, checked: this.props.searchOutput, onChange: this.props.toggleOutput })),\n            React.createElement(\"div\", null,\n                React.createElement(\"span\", { className: this.props.canToggleSelectedCells\n                        ? ''\n                        : SEARCH_OPTIONS_DISABLED_CLASS }, this.props.trans.__('Search Selected Cell(s)')),\n                React.createElement(\"input\", { type: \"checkbox\", disabled: !this.props.canToggleSelectedCells, checked: this.props.searchSelectedCells, onChange: this.props.toggleSelectedCells }))));\n    }\n}\nclass SearchOverlay extends React.Component {\n    constructor(props) {\n        var _a;\n        super(props);\n        this.translator = props.translator || nullTranslator;\n        this.state = props.overlayState;\n        this.replaceEntryRef = React.createRef();\n        this._debouncedStartSearch = new Debouncer(() => {\n            this._executeSearch(true, this.state.searchText);\n        }, (_a = props.searchDebounceTime) !== null && _a !== void 0 ? _a : 500);\n        this._toggleSearchOutput = this._toggleSearchOutput.bind(this);\n        this._toggleSearchSelectedCells = this._toggleSearchSelectedCells.bind(this);\n    }\n    componentDidMount() {\n        if (this.state.searchText) {\n            this._executeSearch(true, this.state.searchText);\n        }\n    }\n    _onSearchChange(event) {\n        const searchText = event.target.value;\n        this.setState({ searchText: searchText });\n        void this._debouncedStartSearch.invoke();\n    }\n    _onReplaceChange(event) {\n        this.setState({ replaceText: event.target.value });\n    }\n    _onSearchKeydown(event) {\n        if (event.keyCode === 13) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._executeSearch(!event.shiftKey);\n        }\n        else if (event.keyCode === 27) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._onClose();\n        }\n    }\n    _onReplaceKeydown(event) {\n        if (event.keyCode === 13) {\n            event.preventDefault();\n            event.stopPropagation();\n            this.props.onReplaceCurrent(this.state.replaceText);\n        }\n    }\n    _executeSearch(goForward, searchText, filterChanged = false) {\n        // execute search!\n        let query;\n        const input = searchText ? searchText : this.state.searchText;\n        try {\n            query = Private.parseQuery(input, this.props.overlayState.caseSensitive, this.props.overlayState.useRegex);\n            this.setState({ errorMessage: '' });\n        }\n        catch (e) {\n            this.setState({ errorMessage: e.message });\n            return;\n        }\n        if (Private.regexEqual(this.props.overlayState.query, query) &&\n            !filterChanged) {\n            if (goForward) {\n                this.props.onHighlightNext();\n            }\n            else {\n                this.props.onHighlightPrevious();\n            }\n            return;\n        }\n        this.props.onStartQuery(query, this.state.filters);\n    }\n    _onClose() {\n        // Clean up and close widget.\n        this.props.onEndSearch();\n        this._debouncedStartSearch.dispose();\n    }\n    _onReplaceToggled() {\n        this.setState({\n            replaceEntryShown: !this.state.replaceEntryShown\n        });\n    }\n    _onSearchInputFocus() {\n        if (!this.state.searchInputFocused) {\n            this.setState({ searchInputFocused: true });\n        }\n    }\n    _onSearchInputBlur() {\n        if (this.state.searchInputFocused) {\n            this.setState({ searchInputFocused: false });\n        }\n    }\n    _toggleSearchOutput() {\n        this.setState(prevState => (Object.assign(Object.assign({}, prevState), { filters: Object.assign(Object.assign({}, prevState.filters), { output: !prevState.filters.output }) })), () => this._executeSearch(true, undefined, true));\n    }\n    _toggleSearchSelectedCells() {\n        this.setState(prevState => (Object.assign(Object.assign({}, prevState), { filters: Object.assign(Object.assign({}, prevState.filters), { selectedCells: !prevState.filters.selectedCells }) })), () => this._executeSearch(true, undefined, true));\n    }\n    _toggleFiltersOpen() {\n        this.setState(prevState => ({\n            filtersOpen: !prevState.filtersOpen\n        }));\n    }\n    render() {\n        const showReplace = !this.props.isReadOnly && this.state.replaceEntryShown;\n        const showFilter = this.props.hasOutputs;\n        const filterToggle = showFilter ? (React.createElement(FilterToggle, { enabled: this.state.filtersOpen, toggleEnabled: () => this._toggleFiltersOpen() })) : null;\n        const filter = showFilter ? (React.createElement(FilterSelection, { key: 'filter', canToggleOutput: !showReplace, canToggleSelectedCells: true, searchOutput: this.state.filters.output, searchSelectedCells: this.state.filters.selectedCells, toggleOutput: this._toggleSearchOutput, toggleSelectedCells: this._toggleSearchSelectedCells, trans: this.translator.load('jupyterlab') })) : null;\n        const icon = this.state.replaceEntryShown ? caretDownIcon : caretRightIcon;\n        // TODO: Error messages from regex are not currently localizable.\n        return [\n            React.createElement(\"div\", { className: OVERLAY_ROW_CLASS, key: 0 },\n                this.props.isReadOnly ? (React.createElement(\"div\", { className: TOGGLE_PLACEHOLDER })) : (React.createElement(\"button\", { className: TOGGLE_WRAPPER, onClick: () => this._onReplaceToggled(), tabIndex: 0 },\n                    React.createElement(icon.react, { className: `${REPLACE_TOGGLE_CLASS} ${BUTTON_CONTENT_CLASS}`, tag: \"span\", elementPosition: \"center\", height: \"20px\", width: \"20px\" }))),\n                React.createElement(SearchEntry, { useRegex: this.props.overlayState.useRegex, caseSensitive: this.props.overlayState.caseSensitive, onCaseSensitiveToggled: () => {\n                        this.props.onCaseSensitiveToggled();\n                        this._executeSearch(true);\n                    }, onRegexToggled: () => {\n                        this.props.onRegexToggled();\n                        this._executeSearch(true);\n                    }, onKeydown: (e) => this._onSearchKeydown(e), onChange: (e) => this._onSearchChange(e), onInputFocus: this._onSearchInputFocus.bind(this), onInputBlur: this._onSearchInputBlur.bind(this), inputFocused: this.state.searchInputFocused, searchText: this.state.searchText, forceFocus: this.props.overlayState.forceFocus, translator: this.translator }),\n                React.createElement(SearchIndices, { currentIndex: this.props.overlayState.currentIndex, totalMatches: this.props.overlayState.totalMatches }),\n                React.createElement(UpDownButtons, { onHighlightPrevious: () => this._executeSearch(false), onHighlightNext: () => this._executeSearch(true) }),\n                showReplace ? null : filterToggle,\n                React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this._onClose(), tabIndex: 0 },\n                    React.createElement(closeIcon.react, { className: \"jp-icon-hover\", elementPosition: \"center\", height: \"16px\", width: \"16px\" }))),\n            React.createElement(\"div\", { className: OVERLAY_ROW_CLASS, key: 1 }, showReplace ? (React.createElement(React.Fragment, null,\n                React.createElement(ReplaceEntry, { onReplaceKeydown: (e) => this._onReplaceKeydown(e), onChange: (e) => this._onReplaceChange(e), onReplaceCurrent: () => this.props.onReplaceCurrent(this.state.replaceText), onReplaceAll: () => this.props.onReplaceAll(this.state.replaceText), replaceText: this.state.replaceText, ref: this.replaceEntryRef, translator: this.translator }),\n                React.createElement(\"div\", { className: SPACER_CLASS }),\n                filterToggle)) : null),\n            this.state.filtersOpen ? filter : null,\n            React.createElement(\"div\", { className: REGEX_ERROR_CLASS, hidden: !!this.state.errorMessage && this.state.errorMessage.length === 0, key: 3 }, this.state.errorMessage),\n            React.createElement(\"div\", { className: SEARCH_DOCUMENT_LOADING, key: 4 }, \"This document is still loading. Only loaded content will appear in search results until the entire document loads.\")\n        ];\n    }\n}\nexport function createSearchOverlay(options) {\n    const { widgetChanged, overlayState, onCaseSensitiveToggled, onRegexToggled, onHighlightNext, onHighlightPrevious, onStartQuery, onReplaceCurrent, onReplaceAll, onEndSearch, isReadOnly, hasOutputs, searchDebounceTime, translator } = options;\n    const widget = ReactWidget.create(React.createElement(UseSignal, { signal: widgetChanged, initialArgs: overlayState }, (_, args) => {\n        return (React.createElement(SearchOverlay, { onCaseSensitiveToggled: onCaseSensitiveToggled, onRegexToggled: onRegexToggled, onHighlightNext: onHighlightNext, onHighlightPrevious: onHighlightPrevious, onStartQuery: onStartQuery, onEndSearch: onEndSearch, onReplaceCurrent: onReplaceCurrent, onReplaceAll: onReplaceAll, overlayState: args, isReadOnly: isReadOnly, hasOutputs: hasOutputs, searchDebounceTime: searchDebounceTime, translator: translator }));\n    }));\n    widget.addClass(OVERLAY_CLASS);\n    return widget;\n}\nvar Private;\n(function (Private) {\n    function parseQuery(queryString, caseSensitive, regex) {\n        const flag = caseSensitive ? 'g' : 'gi';\n        // escape regex characters in query if its a string search\n        const queryText = regex\n            ? queryString\n            : queryString.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n        let ret;\n        ret = new RegExp(queryText, flag);\n        if (ret.test('')) {\n            ret = /x^/;\n        }\n        return ret;\n    }\n    Private.parseQuery = parseQuery;\n    function regexEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        return (a.source === b.source &&\n            a.global === b.global &&\n            a.ignoreCase === b.ignoreCase &&\n            a.multiline === b.multiline);\n    }\n    Private.regexEqual = regexEqual;\n})(Private || (Private = {}));\n//# sourceMappingURL=searchoverlay.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { MainAreaWidget } from '@jupyterlab/apputils';\nimport { NotebookPanel } from '@jupyterlab/notebook';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\nimport { createSearchOverlay } from './searchoverlay';\n/**\n * Represents a search on a single widget.\n */\nexport class SearchInstance {\n    constructor(widget, searchProvider, translator, searchDebounceTime = 500) {\n        this._displayState = {\n            currentIndex: 0,\n            totalMatches: 0,\n            caseSensitive: false,\n            useRegex: false,\n            searchText: '',\n            query: null,\n            errorMessage: '',\n            searchInputFocused: true,\n            replaceInputFocused: false,\n            forceFocus: true,\n            replaceText: '',\n            replaceEntryShown: false,\n            filters: { output: true, selectedCells: false },\n            filtersOpen: false\n        };\n        this._displayUpdateSignal = new Signal(this);\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this.translator = translator || nullTranslator;\n        this._widget = widget;\n        this._activeProvider = searchProvider;\n        const initialQuery = this._activeProvider.getInitialQuery(this._widget);\n        this._displayState.searchText = initialQuery || '';\n        this._searchWidget = createSearchOverlay({\n            widgetChanged: this._displayUpdateSignal,\n            overlayState: this._displayState,\n            onCaseSensitiveToggled: this._onCaseSensitiveToggled.bind(this),\n            onRegexToggled: this._onRegexToggled.bind(this),\n            onHighlightNext: this._highlightNext.bind(this),\n            onHighlightPrevious: this._highlightPrevious.bind(this),\n            onStartQuery: this._startQuery.bind(this),\n            onReplaceCurrent: this._replaceCurrent.bind(this),\n            onReplaceAll: this._replaceAll.bind(this),\n            onEndSearch: this.dispose.bind(this),\n            isReadOnly: this._activeProvider.isReadOnly,\n            hasOutputs: this._activeProvider.hasOutputs || false,\n            searchDebounceTime: searchDebounceTime,\n            translator: this.translator\n        });\n        this._widget.disposed.connect(() => {\n            this.dispose();\n        });\n        this._searchWidget.disposed.connect(() => {\n            this._widget.activate();\n            this.dispose();\n        });\n        // TODO: this does not update if the toolbar changes height.\n        if (this._widget instanceof MainAreaWidget) {\n            // Offset the position of the search widget to not cover the toolbar.\n            this._searchWidget.node.style.top = `${this._widget.toolbar.node.clientHeight}px`;\n        }\n        if (this._widget instanceof NotebookPanel) {\n            this._widget.content.activeCellChanged.connect(() => {\n                if (this._displayState.query &&\n                    this._displayState.filters.selectedCells) {\n                    void this._startQuery(this._displayState.query, this._displayState.filters);\n                }\n            });\n        }\n        this._displaySearchWidget();\n    }\n    /**\n     * The search widget.\n     */\n    get searchWidget() {\n        return this._searchWidget;\n    }\n    /**\n     * The search provider.\n     */\n    get provider() {\n        return this._activeProvider;\n    }\n    /**\n     * Focus the search widget input.\n     */\n    focusInput() {\n        this._displayState.forceFocus = true;\n        this._displayState.searchInputFocused = true;\n        // Trigger a rerender without resetting the forceFocus.\n        this._displayUpdateSignal.emit(this._displayState);\n        this._displayState.forceFocus = false;\n    }\n    /**\n     * If there is a replace box, show it.\n     */\n    showReplace() {\n        this._displayState.replaceEntryShown = true;\n    }\n    /**\n     * Updates the match index and total display in the search widget.\n     */\n    updateIndices() {\n        this._displayState.totalMatches = this._activeProvider.matches.length;\n        this._displayState.currentIndex = this._activeProvider.currentMatchIndex;\n        this._updateDisplay();\n    }\n    _updateDisplay() {\n        // Reset the focus attribute to make sure we don't steal focus.\n        this._displayState.forceFocus = false;\n        // Trigger a rerender\n        this._displayUpdateSignal.emit(this._displayState);\n    }\n    async _startQuery(query, filters) {\n        // save the last query (or set it to the current query if this is the first)\n        if (this._activeProvider && this._displayState.query) {\n            await this._activeProvider.endQuery();\n        }\n        this._displayState.query = query;\n        this._displayState.filters = filters;\n        await this._activeProvider.startQuery(query, this._widget, filters);\n        this.updateIndices();\n        // this signal should get injected when the widget is\n        // created and hooked up to react!\n        this._activeProvider.changed.connect(this.updateIndices, this);\n    }\n    async _replaceCurrent(newText) {\n        if (this._activeProvider && this._displayState.query) {\n            await this._activeProvider.replaceCurrentMatch(newText);\n            this.updateIndices();\n        }\n    }\n    async _replaceAll(newText) {\n        if (this._activeProvider && this._displayState.query) {\n            await this._activeProvider.replaceAllMatches(newText);\n            this.updateIndices();\n        }\n    }\n    /**\n     * Dispose of the resources held by the search instance.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        // If a query hasn't been executed yet, no need to call endSearch\n        if (this._displayState.query) {\n            void this._activeProvider.endSearch();\n        }\n        this._searchWidget.dispose();\n        this._disposed.emit(undefined);\n        Signal.clearData(this);\n    }\n    /**\n     * Test if the object has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A signal emitted when the object is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Display search widget.\n     */\n    _displaySearchWidget() {\n        if (!this._searchWidget.isAttached) {\n            Widget.attach(this._searchWidget, this._widget.node);\n        }\n    }\n    async _highlightNext() {\n        if (!this._displayState.query) {\n            return;\n        }\n        await this._activeProvider.highlightNext();\n        this.updateIndices();\n    }\n    async _highlightPrevious() {\n        if (!this._displayState.query) {\n            return;\n        }\n        await this._activeProvider.highlightPrevious();\n        this.updateIndices();\n    }\n    _onCaseSensitiveToggled() {\n        this._displayState.caseSensitive = !this._displayState.caseSensitive;\n        this._updateDisplay();\n    }\n    _onRegexToggled() {\n        this._displayState.useRegex = !this._displayState.useRegex;\n        this._updateDisplay();\n    }\n}\n//# sourceMappingURL=searchinstance.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Signal } from '@lumino/signaling';\nexport class SearchProviderRegistry {\n    constructor() {\n        this._changed = new Signal(this);\n        this._providerMap = new Map();\n    }\n    /**\n     * Add a provider to the registry.\n     *\n     * @param key - The provider key.\n     * @returns A disposable delegate that, when disposed, deregisters the given search provider\n     */\n    register(key, provider) {\n        this._providerMap.set(key, provider);\n        this._changed.emit();\n        return new DisposableDelegate(() => {\n            this._providerMap.delete(key);\n            this._changed.emit();\n        });\n    }\n    /**\n     * Returns a matching provider for the widget.\n     *\n     * @param widget - The widget to search over.\n     * @returns the search provider, or undefined if none exists.\n     */\n    getProviderForWidget(widget) {\n        return this._findMatchingProvider(this._providerMap, widget);\n    }\n    /**\n     * Signal that emits when a new search provider has been registered\n     * or removed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    _findMatchingProvider(providerMap, widget) {\n        // iterate through all providers and ask each one if it can search on the\n        // widget.\n        for (const P of providerMap.values()) {\n            if (P.canSearchOn(widget)) {\n                return new P();\n            }\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=searchproviderregistry.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The search provider registry token.\n */\nexport const ISearchProviderRegistry = new Token('@jupyterlab/documentsearch:ISearchProviderRegistry');\n//# sourceMappingURL=tokens.js.map"],"names":["CodeMirrorSearchProvider","constructor","this","isReadOnly","isSubProvider","_matchState","_changed","Signal","getInitialQuery","searchTarget","selection","content","editor","doc","getSelection","search","async","query","filters","canSearchOn","Error","_cm","_startQuery","refreshOverlay","_refreshOverlay","endQuery","_query","_onDocChanged","bind","_setInitialMatches","matches","_parseMatchesFromState","length","cursorMatch","_findNext","match","from","line","ch","_currentMatch","removeOverlay","_overlay","getCursor","to","setSelection","start","_toEditorPos","end","focus","newText","replaceOccurred","_currentMatchIsSelected","cursor","getSearchCursor","ignoreCase","findNext","replace","highlightNext","Promise","resolve","_","operation","undefined","static","domain","MainAreaWidget","FileEditor","CodeMirrorEditor","currentMatch","changed","currentMatchIndex","index","clearSelection","changeObj","_a","_b","text","removed","emit","_getSearchOverlay","addOverlay","firstLine","lastLine","getRange","split","forEach","lineNumber","lastIndex","exec","col","matchObj","column","fragment","token","stream","currentPos","pos","lineText","string","lineOracle","matchLength","substr","eol","skipToEnd","reverse","caseSensitive","cursorToGet","lastPosition","position","find","setCursorPosition","scroll","startOrEnd","fromPos","toPos","selRange","scrollIntoView","Object","keys","reduce","result","lineKey","parseInt","lineMatches","posKey","push","posIn","currentSelection","currentSelectionLength","selectionIsOneLine","SearchState","FOUND_CLASSES","SELECTED_CLASSES","GenericSearchProvider","_matches","_mutationObserver","MutationObserver","_onWidgetChanged","that","_widget","disconnect","walker","document","createTreeWalker","node","NodeFilter","SHOW_TEXT","acceptNode","parentElement","nodeName","UNSUPPORTED_ELEMENTS","FILTER_REJECT","test","textContent","FILTER_ACCEPT","nodes","originalNodes","nextNode","cloneNode","flags","indexOf","nodeIndex","q","RegExp","source","subsections","originalNode","originalLength","lastNodeAdded","newMatches","idx","spannedNode","createElement","classList","add","slice","nodeType","Node","TEXT_NODE","endText","splitText","parentNode","insertBefore","prepend","append","unshift","matchesIndex","indexInOriginal","spanElement","observe","attributes","characterData","childList","subtree","replaceWith","_highlightNext","remove","nextIndex","el","boundingClientRect","getBoundingClientRect","top","bottom","window","innerHeight","documentElement","clientHeight","left","right","innerWidth","clientWidth","elementInViewport","Widget","map","m","assign","mutations","observer","startQuery","BASE","HEAD","LINK","META","STYLE","TITLE","BODY","AREA","AUDIO","IMG","MAP","TRACK","VIDEO","APPLET","EMBED","IFRAME","NOEMBED","OBJECT","PARAM","PICTURE","SOURCE","CANVAS","NOSCRIPT","SCRIPT","SVG","NotebookSearchProvider","hasOutputs","_searchProviders","_unRenderedMarkdownCells","_cellsWithMatches","activeCell","_searchTarget","cells","widgets","_filters","entries","output","selectedCells","filter","cell","isSelectedOrActive","hide","indexTotal","allMatches","cmEditor","cmSearchProvider","cellShouldReRender","MarkdownCell","rendered","inputHidden","matchesFromCell","startQueryCodeMirror","connect","_onSearchProviderChanged","concat","provider","CodeCell","outputProvider","matchesFromOutput","outputArea","show","_stepNext","_updatedCurrentProvider","_refreshCurrentCellEditor","_refreshCellsEditorsInBackground","n","i","refreshNextNCells","stop","refresh","setTimeout","queriesEnded","model","_currentProvider","isDisposed","all","activeCellIndex","searchEnded","endSearch","mode","replaceCurrentMatch","replaceAllMatches","NotebookPanel","_getMatchesFromCells","currentProviderIndex","ArrayExt","nextProviderIndex","currentSearchPair","steps","highlightPrevious","providerIndex","numProviders","nextSearchPair","newPosCM","newPos","notebook","cellMatches","cm","OVERLAY_ROW_CLASS","INPUT_BUTTON_CLASS_OFF","INPUT_BUTTON_CLASS_ON","UP_DOWN_BUTTON_CLASS","SEARCH_OPTIONS_DISABLED_CLASS","REPLACE_BUTTON_CLASS","REPLACE_BUTTON_WRAPPER_CLASS","BUTTON_CONTENT_CLASS","BUTTON_WRAPPER_CLASS","SearchEntry","props","super","translator","nullTranslator","_trans","load","searchInputRef","focusInput","current","select","componentDidUpdate","forceFocus","render","caseButtonToggleClass","classes","regexButtonToggleClass","useRegex","wrapperClass","inputFocused","className","placeholder","searchText","__","value","onChange","e","onKeyDown","onKeydown","tabIndex","onFocus","onInputFocus","onBlur","onInputBlur","ref","onClick","onCaseSensitiveToggled","caseSensitiveIcon","tag","onRegexToggled","regexIcon","ReplaceEntry","replaceInputRef","replaceText","onReplaceKeydown","onReplaceCurrent","onReplaceAll","UpDownButtons","onHighlightPrevious","caretUpEmptyThinIcon","onHighlightNext","caretDownEmptyThinIcon","SearchIndices","totalMatches","currentIndex","FilterToggle","enabled","toggleEnabled","ellipsesIcon","height","width","FilterSelection","canToggleOutput","trans","type","disabled","checked","searchOutput","toggleOutput","canToggleSelectedCells","searchSelectedCells","toggleSelectedCells","SearchOverlay","state","overlayState","replaceEntryRef","_debouncedStartSearch","Debouncer","_executeSearch","searchDebounceTime","_toggleSearchOutput","_toggleSearchSelectedCells","componentDidMount","_onSearchChange","event","target","setState","invoke","_onReplaceChange","_onSearchKeydown","keyCode","preventDefault","stopPropagation","shiftKey","_onClose","_onReplaceKeydown","goForward","filterChanged","input","Private","parseQuery","errorMessage","message","regexEqual","onStartQuery","onEndSearch","dispose","_onReplaceToggled","replaceEntryShown","_onSearchInputFocus","searchInputFocused","_onSearchInputBlur","prevState","_toggleFiltersOpen","filtersOpen","showReplace","showFilter","filterToggle","key","icon","caretDownIcon","caretRightIcon","react","elementPosition","closeIcon","hidden","queryString","regex","flag","queryText","ret","a","b","global","multiline","SearchInstance","widget","searchProvider","_displayState","replaceInputFocused","_displayUpdateSignal","_isDisposed","_disposed","_activeProvider","initialQuery","_searchWidget","options","widgetChanged","ReactWidget","UseSignal","signal","initialArgs","args","addClass","createSearchOverlay","_onCaseSensitiveToggled","_onRegexToggled","_highlightPrevious","_replaceCurrent","_replaceAll","disposed","activate","style","toolbar","activeCellChanged","_displaySearchWidget","searchWidget","updateIndices","_updateDisplay","isAttached","SearchProviderRegistry","_providerMap","Map","register","set","DisposableDelegate","delete","getProviderForWidget","_findMatchingProvider","providerMap","P","values","ISearchProviderRegistry","Token"],"sourceRoot":""}