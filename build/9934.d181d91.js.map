{"version":3,"file":"9934.d181d91.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shared-models/lib/ymodels.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/shared-models/lib/utils.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { Awareness } from 'y-protocols/awareness';\nimport * as Y from 'yjs';\nconst deepCopy = (o) => JSON.parse(JSON.stringify(o));\nexport class YDocument {\n    constructor() {\n        this.isDisposed = false;\n        this.ydoc = new Y.Doc();\n        this.source = this.ydoc.getText('source');\n        this.ystate = this.ydoc.getMap('state');\n        this.undoManager = new Y.UndoManager([this.source], {\n            trackedOrigins: new Set([this])\n        });\n        this.awareness = new Awareness(this.ydoc);\n        this._changed = new Signal(this);\n    }\n    get dirty() {\n        return this.ystate.get('dirty');\n    }\n    set dirty(value) {\n        this.transact(() => {\n            this.ystate.set('dirty', value);\n        }, false);\n    }\n    /**\n     * Perform a transaction. While the function f is called, all changes to the shared\n     * document are bundled into a single event.\n     */\n    transact(f, undoable = true) {\n        this.ydoc.transact(f, undoable ? this : null);\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        this.isDisposed = true;\n        this.ydoc.destroy();\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    canUndo() {\n        return this.undoManager.undoStack.length > 0;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    canRedo() {\n        return this.undoManager.redoStack.length > 0;\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        this.undoManager.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        this.undoManager.redo();\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndoHistory() {\n        this.undoManager.clear();\n    }\n    /**\n     * The changed signal.\n     */\n    get changed() {\n        return this._changed;\n    }\n}\nexport class YFile extends YDocument {\n    constructor() {\n        super();\n        /**\n         * Handle a change to the ymodel.\n         */\n        this._modelObserver = (event) => {\n            const changes = {};\n            changes.sourceChange = event.changes.delta;\n            this._changed.emit(changes);\n        };\n        /**\n         * Handle a change to the ystate.\n         */\n        this._onStateChanged = (event) => {\n            const stateChange = [];\n            event.keysChanged.forEach(key => {\n                const change = event.changes.keys.get(key);\n                if (change) {\n                    stateChange.push({\n                        name: key,\n                        oldValue: change.oldValue,\n                        newValue: this.ystate.get(key)\n                    });\n                }\n            });\n            this._changed.emit({ stateChange });\n        };\n        this.ysource = this.ydoc.getText('source');\n        this.ysource.observe(this._modelObserver);\n        this.ystate.observe(this._onStateChanged);\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        this.ysource.unobserve(this._modelObserver);\n        this.ystate.unobserve(this._onStateChanged);\n    }\n    static create() {\n        return new YFile();\n    }\n    /**\n     * Gets cell's source.\n     *\n     * @returns Cell's source.\n     */\n    getSource() {\n        return this.ysource.toString();\n    }\n    /**\n     * Sets cell's source.\n     *\n     * @param value: New source.\n     */\n    setSource(value) {\n        this.transact(() => {\n            const ytext = this.ysource;\n            ytext.delete(0, ytext.length);\n            ytext.insert(0, value);\n        });\n    }\n    /**\n     * Replace content from `start' to `end` with `value`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param value: New source (optional).\n     */\n    updateSource(start, end, value = '') {\n        this.transact(() => {\n            const ysource = this.ysource;\n            // insert and then delete.\n            // This ensures that the cursor position is adjusted after the replaced content.\n            ysource.insert(start, value);\n            ysource.delete(start + value.length, end - start);\n        });\n    }\n}\n/**\n * Shared implementation of the Shared Document types.\n *\n * Shared cells can be inserted into a SharedNotebook.\n * Shared cells only start emitting events when they are connected to a SharedNotebook.\n *\n * \"Standalone\" cells must not be inserted into a (Shared)Notebook.\n * Standalone cells emit events immediately after they have been created, but they must not\n * be included into a (Shared)Notebook.\n */\nexport class YNotebook extends YDocument {\n    constructor(options) {\n        super();\n        /**\n         * Handle a change to the list of cells.\n         */\n        this._onYCellsChanged = (event) => {\n            // update the typeâ‡”cell mapping by iterating through the added/removed types\n            event.changes.added.forEach(item => {\n                const type = item.content.type;\n                if (!this._ycellMapping.has(type)) {\n                    this._ycellMapping.set(type, createCellFromType(type));\n                }\n                const cell = this._ycellMapping.get(type);\n                cell._notebook = this;\n                if (!this.disableDocumentWideUndoRedo) {\n                    cell._undoManager = this.undoManager;\n                }\n                else {\n                    cell._undoManager = new Y.UndoManager([cell.ymodel], {});\n                }\n            });\n            event.changes.deleted.forEach(item => {\n                const type = item.content.type;\n                const model = this._ycellMapping.get(type);\n                if (model) {\n                    model.dispose();\n                    this._ycellMapping.delete(type);\n                }\n            });\n            let index = 0;\n            // this reflects the event.changes.delta, but replaces the content of delta.insert with ycells\n            const cellsChange = [];\n            event.changes.delta.forEach((d) => {\n                if (d.insert != null) {\n                    const insertedCells = d.insert.map((ycell) => this._ycellMapping.get(ycell));\n                    cellsChange.push({ insert: insertedCells });\n                    this.cells.splice(index, 0, ...insertedCells);\n                    index += d.insert.length;\n                }\n                else if (d.delete != null) {\n                    cellsChange.push(d);\n                    this.cells.splice(index, d.delete);\n                }\n                else if (d.retain != null) {\n                    cellsChange.push(d);\n                    index += d.retain;\n                }\n            });\n            this._changed.emit({\n                cellsChange: cellsChange\n            });\n        };\n        /**\n         * Handle a change to the ystate.\n         */\n        this._onMetadataChanged = (event) => {\n            if (event.keysChanged.has('metadata')) {\n                const change = event.changes.keys.get('metadata');\n                const metadataChange = {\n                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,\n                    newValue: this.getMetadata()\n                };\n                this._changed.emit({ metadataChange });\n            }\n        };\n        /**\n         * Handle a change to the ystate.\n         */\n        this._onStateChanged = (event) => {\n            const stateChange = [];\n            event.keysChanged.forEach(key => {\n                const change = event.changes.keys.get(key);\n                if (change) {\n                    stateChange.push({\n                        name: key,\n                        oldValue: change.oldValue,\n                        newValue: this.ystate.get(key)\n                    });\n                }\n            });\n            this._changed.emit({ stateChange });\n        };\n        this.ycells = this.ydoc.getArray('cells');\n        this.ymeta = this.ydoc.getMap('meta');\n        this.ymodel = this.ydoc.getMap('model');\n        this.undoManager = new Y.UndoManager([this.ycells], {\n            trackedOrigins: new Set([this])\n        });\n        this._ycellMapping = new Map();\n        this._disableDocumentWideUndoRedo = options.disableDocumentWideUndoRedo;\n        this.ycells.observe(this._onYCellsChanged);\n        this.cells = this.ycells.toArray().map(ycell => {\n            if (!this._ycellMapping.has(ycell)) {\n                this._ycellMapping.set(ycell, createCellFromType(ycell));\n            }\n            return this._ycellMapping.get(ycell);\n        });\n        this.ymeta.observe(this._onMetadataChanged);\n        this.ystate.observe(this._onStateChanged);\n    }\n    get nbformat() {\n        return this.ystate.get('nbformat');\n    }\n    set nbformat(value) {\n        this.transact(() => {\n            this.ystate.set('nbformat', value);\n        }, false);\n    }\n    get nbformat_minor() {\n        return this.ystate.get('nbformatMinor');\n    }\n    set nbformat_minor(value) {\n        this.transact(() => {\n            this.ystate.set('nbformatMinor', value);\n        }, false);\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        this.ycells.unobserve(this._onYCellsChanged);\n        this.ymeta.unobserve(this._onMetadataChanged);\n        this.ystate.unobserve(this._onStateChanged);\n    }\n    /**\n     * Get a shared cell by index.\n     *\n     * @param index: Cell's position.\n     *\n     * @returns The requested shared cell.\n     */\n    getCell(index) {\n        return this.cells[index];\n    }\n    /**\n     * Insert a shared cell into a specific position.\n     *\n     * @param index: Cell's position.\n     *\n     * @param cell: Cell to insert.\n     */\n    insertCell(index, cell) {\n        this.insertCells(index, [cell]);\n    }\n    /**\n     * Insert a list of shared cells into a specific position.\n     *\n     * @param index: Position to insert the cells.\n     *\n     * @param cells: Array of shared cells to insert.\n     */\n    insertCells(index, cells) {\n        cells.forEach(cell => {\n            this._ycellMapping.set(cell.ymodel, cell);\n            if (!this.disableDocumentWideUndoRedo) {\n                cell.undoManager = this.undoManager;\n            }\n        });\n        this.transact(() => {\n            this.ycells.insert(index, cells.map(cell => cell.ymodel));\n        });\n    }\n    /**\n     * Move a cell.\n     *\n     * @param fromIndex: Index of the cell to move.\n     *\n     * @param toIndex: New position of the cell.\n     */\n    moveCell(fromIndex, toIndex) {\n        this.transact(() => {\n            const fromCell = this.getCell(fromIndex).clone();\n            this.deleteCell(fromIndex);\n            this.insertCell(toIndex, fromCell);\n        });\n    }\n    /**\n     * Remove a cell.\n     *\n     * @param index: Index of the cell to remove.\n     */\n    deleteCell(index) {\n        this.deleteCellRange(index, index + 1);\n    }\n    /**\n     * Remove a range of cells.\n     *\n     * @param from: The start index of the range to remove (inclusive).\n     *\n     * @param to: The end index of the range to remove (exclusive).\n     */\n    deleteCellRange(from, to) {\n        this.transact(() => {\n            this.ycells.delete(from, to - from);\n        });\n    }\n    /**\n     * Returns the metadata associated with the notebook.\n     *\n     * @returns Notebook's metadata.\n     */\n    getMetadata() {\n        const meta = this.ymeta.get('metadata');\n        return meta ? deepCopy(meta) : {};\n    }\n    /**\n     * Sets the metadata associated with the notebook.\n     *\n     * @param metadata: Notebook's metadata.\n     */\n    setMetadata(value) {\n        this.ymeta.set('metadata', deepCopy(value));\n    }\n    /**\n     * Updates the metadata associated with the notebook.\n     *\n     * @param value: Metadata's attribute to update.\n     */\n    updateMetadata(value) {\n        // TODO: Maybe modify only attributes instead of replacing the whole metadata?\n        this.ymeta.set('metadata', Object.assign({}, this.getMetadata(), value));\n    }\n    /**\n     * Create a new YNotebook.\n     */\n    static create(disableDocumentWideUndoRedo) {\n        return new YNotebook({ disableDocumentWideUndoRedo });\n    }\n    /**\n     * Wether the the undo/redo logic should be\n     * considered on the full document across all cells.\n     *\n     * @return The disableDocumentWideUndoRedo setting.\n     */\n    get disableDocumentWideUndoRedo() {\n        return this._disableDocumentWideUndoRedo;\n    }\n}\n/**\n * Create a new shared cell given the type.\n */\nexport const createCellFromType = (type) => {\n    switch (type.get('cell_type')) {\n        case 'code':\n            return new YCodeCell(type);\n        case 'markdown':\n            return new YMarkdownCell(type);\n        case 'raw':\n            return new YRawCell(type);\n        default:\n            throw new Error('Found unknown cell type');\n    }\n};\n/**\n * Create a new standalone cell given the type.\n */\nexport const createStandaloneCell = (cellType, id) => {\n    switch (cellType) {\n        case 'markdown':\n            return YMarkdownCell.createStandalone(id);\n        case 'code':\n            return YCodeCell.createStandalone(id);\n        default:\n            // raw\n            return YRawCell.createStandalone(id);\n    }\n};\nexport class YBaseCell {\n    constructor(ymodel) {\n        /**\n         * The notebook that this cell belongs to.\n         */\n        this._notebook = null;\n        /**\n         * Whether the cell is standalone or not.\n         *\n         * If the cell is standalone. It cannot be\n         * inserted into a YNotebook because the Yjs model is already\n         * attached to an anonymous Y.Doc instance.\n         */\n        this.isStandalone = false;\n        /**\n         * Handle a change to the ymodel.\n         */\n        this._modelObserver = (events) => {\n            const changes = {};\n            const sourceEvent = events.find(event => event.target === this.ymodel.get('source'));\n            if (sourceEvent) {\n                changes.sourceChange = sourceEvent.changes.delta;\n            }\n            const outputEvent = events.find(event => event.target === this.ymodel.get('outputs'));\n            if (outputEvent) {\n                changes.outputsChange = outputEvent.changes.delta;\n            }\n            const modelEvent = events.find(event => event.target === this.ymodel);\n            if (modelEvent && modelEvent.keysChanged.has('metadata')) {\n                const change = modelEvent.changes.keys.get('metadata');\n                changes.metadataChange = {\n                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,\n                    newValue: this.getMetadata()\n                };\n            }\n            if (modelEvent && modelEvent.keysChanged.has('execution_count')) {\n                const change = modelEvent.changes.keys.get('execution_count');\n                changes.executionCountChange = {\n                    oldValue: change.oldValue,\n                    newValue: this.ymodel.get('execution_count')\n                };\n            }\n            // The model allows us to replace the complete source with a new string. We express this in the Delta format\n            // as a replace of the complete string.\n            const ysource = this.ymodel.get('source');\n            if (modelEvent && modelEvent.keysChanged.has('source')) {\n                changes.sourceChange = [\n                    { delete: this._prevSourceLength },\n                    { insert: ysource.toString() }\n                ];\n            }\n            this._prevSourceLength = ysource.length;\n            this._changed.emit(changes);\n        };\n        this.isDisposed = false;\n        this._undoManager = null;\n        this._changed = new Signal(this);\n        this.ymodel = ymodel;\n        const ysource = ymodel.get('source');\n        this._prevSourceLength = ysource ? ysource.length : 0;\n        this.ymodel.observeDeep(this._modelObserver);\n        this._awareness = null;\n    }\n    get ysource() {\n        return this.ymodel.get('source');\n    }\n    get awareness() {\n        var _a, _b, _c;\n        return (_c = (_a = this._awareness) !== null && _a !== void 0 ? _a : (_b = this.notebook) === null || _b === void 0 ? void 0 : _b.awareness) !== null && _c !== void 0 ? _c : null;\n    }\n    /**\n     * Perform a transaction. While the function f is called, all changes to the shared\n     * document are bundled into a single event.\n     */\n    transact(f, undoable = true) {\n        this.notebook && undoable\n            ? this.notebook.transact(f)\n            : this.ymodel.doc.transact(f, this);\n    }\n    /**\n     * The notebook that this cell belongs to.\n     */\n    get undoManager() {\n        var _a;\n        if (!this.notebook) {\n            return this._undoManager;\n        }\n        return ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.disableDocumentWideUndoRedo) ? this._undoManager\n            : this.notebook.undoManager;\n    }\n    /**\n     * Set the undoManager when adding new cells.\n     */\n    set undoManager(undoManager) {\n        this._undoManager = undoManager;\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.redo();\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    canUndo() {\n        return !!this.undoManager && this.undoManager.undoStack.length > 0;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    canRedo() {\n        return !!this.undoManager && this.undoManager.redoStack.length > 0;\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndoHistory() {\n        var _a;\n        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    /**\n     * The notebook that this cell belongs to.\n     */\n    get notebook() {\n        return this._notebook;\n    }\n    /**\n     * Create a new YRawCell that can be inserted into a YNotebook\n     */\n    static create(id = UUID.uuid4()) {\n        const ymodel = new Y.Map();\n        const ysource = new Y.Text();\n        ymodel.set('source', ysource);\n        ymodel.set('metadata', {});\n        ymodel.set('cell_type', this.prototype.cell_type);\n        ymodel.set('id', id);\n        return new this(ymodel);\n    }\n    /**\n     * Create a new YRawCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        const cell = this.create(id);\n        cell.isStandalone = true;\n        const doc = new Y.Doc();\n        doc.getArray().insert(0, [cell.ymodel]);\n        cell._awareness = new Awareness(doc);\n        cell._undoManager = new Y.UndoManager([cell.ymodel], {\n            trackedOrigins: new Set([cell])\n        });\n        return cell;\n    }\n    /**\n     * Clone the cell.\n     *\n     * @todo clone should only be available in the specific implementations i.e. ISharedCodeCell\n     */\n    clone() {\n        const ymodel = new Y.Map();\n        const ysource = new Y.Text(this.getSource());\n        ymodel.set('source', ysource);\n        ymodel.set('metadata', this.getMetadata());\n        ymodel.set('cell_type', this.cell_type);\n        ymodel.set('id', this.getId());\n        const Self = this.constructor;\n        const clone = new Self(ymodel);\n        // TODO The assignment of the undoManager does not work for a clone.\n        // See https://github.com/jupyterlab/jupyterlab/issues/11035\n        clone._undoManager = this.undoManager;\n        return clone;\n    }\n    /**\n     * The changed signal.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Dispose of the resources.\n     */\n    dispose() {\n        this.ymodel.unobserveDeep(this._modelObserver);\n    }\n    /**\n     * Gets the cell attachments.\n     *\n     * @returns The cell attachments.\n     */\n    getAttachments() {\n        return this.ymodel.get('attachments');\n    }\n    /**\n     * Sets the cell attachments\n     *\n     * @param attachments: The cell attachments.\n     */\n    setAttachments(attachments) {\n        this.transact(() => {\n            if (attachments == null) {\n                this.ymodel.delete('attachments');\n            }\n            else {\n                this.ymodel.set('attachments', attachments);\n            }\n        });\n    }\n    /**\n     * Get cell id.\n     *\n     * @returns Cell id\n     */\n    getId() {\n        return this.ymodel.get('id');\n    }\n    /**\n     * Gets cell's source.\n     *\n     * @returns Cell's source.\n     */\n    getSource() {\n        return this.ymodel.get('source').toString();\n    }\n    /**\n     * Sets cell's source.\n     *\n     * @param value: New source.\n     */\n    setSource(value) {\n        const ytext = this.ymodel.get('source');\n        this.transact(() => {\n            ytext.delete(0, ytext.length);\n            ytext.insert(0, value);\n        });\n        // @todo Do we need proper replace semantic? This leads to issues in editor bindings because they don't switch source.\n        // this.ymodel.set('source', new Y.Text(value));\n    }\n    /**\n     * Replace content from `start' to `end` with `value`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param value: New source (optional).\n     */\n    updateSource(start, end, value = '') {\n        this.transact(() => {\n            const ysource = this.ysource;\n            // insert and then delete.\n            // This ensures that the cursor position is adjusted after the replaced content.\n            ysource.insert(start, value);\n            ysource.delete(start + value.length, end - start);\n        });\n    }\n    /**\n     * The type of the cell.\n     */\n    get cell_type() {\n        throw new Error('A YBaseCell must not be constructed');\n    }\n    /**\n     * Returns the metadata associated with the notebook.\n     *\n     * @returns Notebook's metadata.\n     */\n    getMetadata() {\n        return deepCopy(this.ymodel.get('metadata'));\n    }\n    /**\n     * Sets the metadata associated with the notebook.\n     *\n     * @param metadata: Notebook's metadata.\n     */\n    setMetadata(value) {\n        this.transact(() => {\n            this.ymodel.set('metadata', deepCopy(value));\n        });\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: this.cell_type,\n            source: this.getSource(),\n            metadata: this.getMetadata()\n        };\n    }\n}\nexport class YCodeCell extends YBaseCell {\n    /**\n     * The type of the cell.\n     */\n    get cell_type() {\n        return 'code';\n    }\n    /**\n     * The code cell's prompt number. Will be null if the cell has not been run.\n     */\n    get execution_count() {\n        return this.ymodel.get('execution_count');\n    }\n    /**\n     * The code cell's prompt number. Will be null if the cell has not been run.\n     */\n    set execution_count(count) {\n        this.transact(() => {\n            this.ymodel.set('execution_count', count);\n        });\n    }\n    /**\n     * Execution, display, or stream outputs.\n     */\n    getOutputs() {\n        return deepCopy(this.ymodel.get('outputs').toArray());\n    }\n    /**\n     * Replace all outputs.\n     */\n    setOutputs(outputs) {\n        const youtputs = this.ymodel.get('outputs');\n        this.transact(() => {\n            youtputs.delete(0, youtputs.length);\n            youtputs.insert(0, outputs);\n        }, false);\n    }\n    /**\n     * Replace content from `start' to `end` with `outputs`.\n     *\n     * @param start: The start index of the range to replace (inclusive).\n     *\n     * @param end: The end index of the range to replace (exclusive).\n     *\n     * @param outputs: New outputs (optional).\n     */\n    updateOutputs(start, end, outputs = []) {\n        const youtputs = this.ymodel.get('outputs');\n        const fin = end < youtputs.length ? end - start : youtputs.length - start;\n        this.transact(() => {\n            youtputs.delete(start, fin);\n            youtputs.insert(start, outputs);\n        }, false);\n    }\n    /**\n     * Create a new YCodeCell that can be inserted into a YNotebook\n     */\n    static create(id) {\n        const cell = super.create(id);\n        cell.ymodel.set('execution_count', 0); // for some default value\n        cell.ymodel.set('outputs', new Y.Array());\n        return cell;\n    }\n    /**\n     * Create a new YCodeCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        const cell = super.createStandalone(id);\n        cell.ymodel.set('execution_count', null); // for some default value\n        cell.ymodel.set('outputs', new Y.Array());\n        return cell;\n    }\n    /**\n     * Create a new YCodeCell that can be inserted into a YNotebook\n     *\n     * @todo clone should only be available in the specific implementations i.e. ISharedCodeCell\n     */\n    clone() {\n        const cell = super.clone();\n        const youtputs = new Y.Array();\n        youtputs.insert(0, this.getOutputs());\n        cell.ymodel.set('execution_count', this.execution_count); // for some default value\n        cell.ymodel.set('outputs', youtputs);\n        return cell;\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'code',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            outputs: this.getOutputs(),\n            execution_count: this.execution_count\n        };\n    }\n}\nexport class YRawCell extends YBaseCell {\n    /**\n     * Create a new YRawCell that can be inserted into a YNotebook\n     */\n    static create(id) {\n        return super.create(id);\n    }\n    /**\n     * Create a new YRawCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        return super.createStandalone(id);\n    }\n    /**\n     * String identifying the type of cell.\n     */\n    get cell_type() {\n        return 'raw';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'raw',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            attachments: this.getAttachments()\n        };\n    }\n}\nexport class YMarkdownCell extends YBaseCell {\n    /**\n     * Create a new YMarkdownCell that can be inserted into a YNotebook\n     */\n    static create(id) {\n        return super.create(id);\n    }\n    /**\n     * Create a new YMarkdownCell that works standalone. It cannot be\n     * inserted into a YNotebook because the Yjs model is already\n     * attached to an anonymous Y.Doc instance.\n     */\n    static createStandalone(id) {\n        return super.createStandalone(id);\n    }\n    /**\n     * String identifying the type of cell.\n     */\n    get cell_type() {\n        return 'markdown';\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        return {\n            id: this.getId(),\n            cell_type: 'markdown',\n            source: this.getSource(),\n            metadata: this.getMetadata(),\n            attachments: this.getAttachments()\n        };\n    }\n}\nexport default YNotebook;\n//# sourceMappingURL=ymodels.js.map","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nexport function convertYMapEventToMapChange(event) {\n    let changes = new Map();\n    event.changes.keys.forEach((event, key) => {\n        changes.set(key, {\n            action: event.action,\n            oldValue: event.oldValue,\n            newValue: this.ymeta.get(key)\n        });\n    });\n    return changes;\n}\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n */\nexport const createMutex = () => {\n    let token = true;\n    return (f) => {\n        if (token) {\n            token = false;\n            try {\n                f();\n            }\n            finally {\n                token = true;\n            }\n        }\n    };\n};\n//# sourceMappingURL=utils.js.map"],"names":["deepCopy","o","JSON","parse","stringify","YDocument","constructor","this","isDisposed","ydoc","source","getText","ystate","getMap","undoManager","trackedOrigins","Set","awareness","_changed","Signal","dirty","get","value","transact","set","f","undoable","dispose","destroy","canUndo","undoStack","length","canRedo","redoStack","undo","redo","clearUndoHistory","clear","changed","YFile","super","_modelObserver","event","changes","sourceChange","delta","emit","_onStateChanged","stateChange","keysChanged","forEach","key","change","keys","push","name","oldValue","newValue","ysource","observe","unobserve","static","getSource","toString","setSource","ytext","delete","insert","updateSource","start","end","YNotebook","options","_onYCellsChanged","added","item","type","content","_ycellMapping","has","createCellFromType","cell","_notebook","disableDocumentWideUndoRedo","_undoManager","ymodel","deleted","model","index","cellsChange","d","insertedCells","map","ycell","cells","splice","retain","_onMetadataChanged","metadataChange","undefined","getMetadata","ycells","getArray","ymeta","Map","_disableDocumentWideUndoRedo","toArray","nbformat","nbformat_minor","getCell","insertCell","insertCells","moveCell","fromIndex","toIndex","fromCell","clone","deleteCell","deleteCellRange","from","to","meta","setMetadata","updateMetadata","Object","assign","YCodeCell","YMarkdownCell","YRawCell","Error","createStandaloneCell","cellType","id","createStandalone","YBaseCell","isStandalone","events","sourceEvent","find","target","outputEvent","outputsChange","modelEvent","executionCountChange","_prevSourceLength","observeDeep","_awareness","_a","_b","_c","notebook","doc","UUID","prototype","cell_type","create","getId","Self","unobserveDeep","getAttachments","setAttachments","attachments","toJSON","metadata","execution_count","count","getOutputs","setOutputs","outputs","youtputs","updateOutputs","fin","convertYMapEventToMapChange","action","createMutex","token"],"sourceRoot":""}