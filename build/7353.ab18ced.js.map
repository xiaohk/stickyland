{"version":3,"file":"7353.ab18ced.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/inspector-extension/lib/index.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module inspector-extension\n */\nimport { ILabShell, ILayoutRestorer } from '@jupyterlab/application';\nimport { ICommandPalette, MainAreaWidget, WidgetTracker } from '@jupyterlab/apputils';\nimport { IConsoleTracker } from '@jupyterlab/console';\nimport { IInspector, InspectionHandler, InspectorPanel, KernelConnector } from '@jupyterlab/inspector';\nimport { ILauncher } from '@jupyterlab/launcher';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { inspectorIcon } from '@jupyterlab/ui-components';\n/**\n * The command IDs used by the inspector plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.open = 'inspector:open';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A service providing code introspection.\n */\nconst inspector = {\n    id: '@jupyterlab/inspector-extension:inspector',\n    requires: [ITranslator],\n    optional: [ICommandPalette, ILauncher, ILayoutRestorer],\n    provides: IInspector,\n    autoStart: true,\n    activate: (app, translator, palette, launcher, restorer) => {\n        const trans = translator.load('jupyterlab');\n        const { commands, shell } = app;\n        const command = CommandIDs.open;\n        const label = trans.__('Show Contextual Help');\n        const namespace = 'inspector';\n        const tracker = new WidgetTracker({\n            namespace\n        });\n        function isInspectorOpen() {\n            return inspector && !inspector.isDisposed;\n        }\n        let source = null;\n        let inspector;\n        function openInspector(args) {\n            var _a;\n            if (!isInspectorOpen()) {\n                inspector = new MainAreaWidget({\n                    content: new InspectorPanel({ translator })\n                });\n                inspector.id = 'jp-inspector';\n                inspector.title.label = label;\n                inspector.title.icon = inspectorIcon;\n                void tracker.add(inspector);\n                source = source && !source.isDisposed ? source : null;\n                inspector.content.source = source;\n                (_a = inspector.content.source) === null || _a === void 0 ? void 0 : _a.onEditorChange(args);\n            }\n            if (!inspector.isAttached) {\n                shell.add(inspector, 'main', { activate: false, mode: 'split-right' });\n            }\n            shell.activateById(inspector.id);\n            return inspector;\n        }\n        // Add command to registry.\n        commands.addCommand(command, {\n            caption: trans.__('Live updating code documentation from the active kernel'),\n            isEnabled: () => !inspector ||\n                inspector.isDisposed ||\n                !inspector.isAttached ||\n                !inspector.isVisible,\n            label,\n            icon: args => (args.isLauncher ? inspectorIcon : undefined),\n            execute: args => {\n                var _a;\n                const text = args && args.text;\n                const refresh = args && args.refresh;\n                // if inspector is open, see if we need a refresh\n                if (isInspectorOpen() && refresh)\n                    (_a = inspector.content.source) === null || _a === void 0 ? void 0 : _a.onEditorChange(text);\n                else\n                    openInspector(text);\n            }\n        });\n        // Add command to UI where possible.\n        if (palette) {\n            palette.addItem({ command, category: label });\n        }\n        if (launcher) {\n            launcher.add({ command, args: { isLauncher: true } });\n        }\n        // Handle state restoration.\n        if (restorer) {\n            void restorer.restore(tracker, { command, name: () => 'inspector' });\n        }\n        // Create a proxy to pass the `source` to the current inspector.\n        const proxy = Object.defineProperty({}, 'source', {\n            get: () => !inspector || inspector.isDisposed ? null : inspector.content.source,\n            set: (src) => {\n                source = src && !src.isDisposed ? src : null;\n                if (inspector && !inspector.isDisposed) {\n                    inspector.content.source = source;\n                }\n            }\n        });\n        return proxy;\n    }\n};\n/**\n * An extension that registers consoles for inspection.\n */\nconst consoles = {\n    id: '@jupyterlab/inspector-extension:consoles',\n    requires: [IInspector, IConsoleTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, consoles, labShell, translator) => {\n        // Maintain association of new consoles with their respective handlers.\n        const handlers = {};\n        // Create a handler for each console that is created.\n        consoles.widgetAdded.connect((sender, parent) => {\n            const sessionContext = parent.console.sessionContext;\n            const rendermime = parent.console.rendermime;\n            const connector = new KernelConnector({ sessionContext });\n            const handler = new InspectionHandler({ connector, rendermime });\n            // Associate the handler to the widget.\n            handlers[parent.id] = handler;\n            // Set the initial editor.\n            const cell = parent.console.promptCell;\n            handler.editor = cell && cell.editor;\n            // Listen for prompt creation.\n            parent.console.promptCellCreated.connect((sender, cell) => {\n                handler.editor = cell && cell.editor;\n            });\n            // Listen for parent disposal.\n            parent.disposed.connect(() => {\n                delete handlers[parent.id];\n                handler.dispose();\n            });\n        });\n        // Keep track of console instances and set inspector source.\n        labShell.currentChanged.connect((_, args) => {\n            const widget = args.newValue;\n            if (!widget || !consoles.has(widget)) {\n                return;\n            }\n            const source = handlers[widget.id];\n            if (source) {\n                manager.source = source;\n            }\n        });\n    }\n};\n/**\n * An extension that registers notebooks for inspection.\n */\nconst notebooks = {\n    id: '@jupyterlab/inspector-extension:notebooks',\n    requires: [IInspector, INotebookTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, notebooks, labShell) => {\n        // Maintain association of new notebooks with their respective handlers.\n        const handlers = {};\n        // Create a handler for each notebook that is created.\n        notebooks.widgetAdded.connect((sender, parent) => {\n            const sessionContext = parent.sessionContext;\n            const rendermime = parent.content.rendermime;\n            const connector = new KernelConnector({ sessionContext });\n            const handler = new InspectionHandler({ connector, rendermime });\n            // Associate the handler to the widget.\n            handlers[parent.id] = handler;\n            // Set the initial editor.\n            const cell = parent.content.activeCell;\n            handler.editor = cell && cell.editor;\n            // Listen for active cell changes.\n            parent.content.activeCellChanged.connect((sender, cell) => {\n                handler.editor = cell && cell.editor;\n            });\n            // Listen for parent disposal.\n            parent.disposed.connect(() => {\n                delete handlers[parent.id];\n                handler.dispose();\n            });\n        });\n        // Keep track of notebook instances and set inspector source.\n        labShell.currentChanged.connect((sender, args) => {\n            const widget = args.newValue;\n            if (!widget || !notebooks.has(widget)) {\n                return;\n            }\n            const source = handlers[widget.id];\n            if (source) {\n                manager.source = source;\n            }\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [inspector, consoles, notebooks];\nexport default plugins;\n//# sourceMappingURL=index.js.map"],"names":["CommandIDs","open","id","requires","ITranslator","optional","ICommandPalette","ILauncher","ILayoutRestorer","provides","IInspector","autoStart","activate","app","translator","palette","launcher","restorer","trans","load","commands","shell","command","label","__","tracker","WidgetTracker","namespace","isInspectorOpen","inspector","isDisposed","source","addCommand","caption","isEnabled","isAttached","isVisible","icon","args","isLauncher","inspectorIcon","undefined","execute","_a","text","refresh","content","onEditorChange","MainAreaWidget","InspectorPanel","title","add","mode","activateById","openInspector","addItem","category","restore","name","Object","defineProperty","get","set","src","IConsoleTracker","ILabShell","manager","consoles","labShell","handlers","widgetAdded","connect","sender","parent","sessionContext","console","rendermime","connector","KernelConnector","handler","InspectionHandler","cell","promptCell","editor","promptCellCreated","disposed","dispose","currentChanged","_","widget","newValue","has","INotebookTracker","notebooks","activeCell","activeCellChanged"],"sourceRoot":""}